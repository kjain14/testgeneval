Instance ID: pydata__xarray-6135-16536

Baseline 1 (Pynguin):
Predicted Test Suite: 
Coverage: -1
Mutation Score: -1

Baseline 2 (CodaMosa):
Predicted Test Suite: 
Coverage: -1
Mutation Score: -1

Baseline 3 (GPT-4o):
Predicted Test Suite: 
import pytest
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
from xarray.coding.cftime_offsets import (
    _MONTH_ABBREVIATIONS,
    BaseCFTimeOffset,
    Day,
    Hour,
    Microsecond,
    Millisecond,
    Minute,
    MonthBegin,
    MonthEnd,
    QuarterBegin,
    QuarterEnd,
    Second,
    Tick,
    YearBegin,
    YearEnd,
    _days_in_month,
    cftime_range,
    date_range,
    date_range_like,
    get_date_type,
    to_cftime_datetime,
    to_offset,
)

try:
    import cftime
except ImportError:
    cftime = None


def test_get_date_type():
    if cftime is not None:
        assert get_date_type("noleap") == cftime.DatetimeNoLeap
        assert get_date_type("360_day") == cftime.Datetime360Day
        assert get_date_type("gregorian", use_cftime=False) == pd.Timestamp
        with pytest.raises(KeyError):
            get_date_type("unknown_calendar")


def test_BaseCFTimeOffset_init():
    offset = BaseCFTimeOffset(2)
    assert offset.n == 2
    with pytest.raises(TypeError):
        BaseCFTimeOffset("not_an_int")


def test_BaseCFTimeOffset_eq():
    offset1 = BaseCFTimeOffset(2)
    offset2 = BaseCFTimeOffset(2)
    offset3 = BaseCFTimeOffset(3)
    assert offset1 == offset2
    assert offset1 != offset3


def test_BaseCFTimeOffset_add():
    offset = BaseCFTimeOffset(2)
    with pytest.raises(NotImplementedError):
        offset + 1


def test_BaseCFTimeOffset_sub():
    offset = BaseCFTimeOffset(2)
    with pytest.raises(NotImplementedError):
        offset - 1


def test_Tick_mul():
    tick = Day(1)
    assert tick * 2 == Day(2)
    assert 2 * tick == Day(2)
    with pytest.raises(NotImplementedError):
        tick * 2.5


def test_Tick_next_higher_resolution():
    tick = Day(1)
    assert tick._next_higher_resolution() == Hour(24)


def test_MonthBegin_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 1, 15)
        offset = MonthBegin(1)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2000, 2, 1)


def test_MonthEnd_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 1, 15)
        offset = MonthEnd(1)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2000, 1, 31)


def test_QuarterBegin_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 1, 15)
        offset = QuarterBegin(1, month=1)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2000, 4, 1)


def test_QuarterEnd_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 1, 15)
        offset = QuarterEnd(1, month=3)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2000, 3, 31)


def test_YearBegin_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 6, 15)
        offset = YearBegin(1, month=1)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2001, 1, 1)


def test_YearEnd_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 6, 15)
        offset = YearEnd(1, month=12)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2000, 12, 31)


def test_to_offset():
    assert isinstance(to_offset("D"), Day)
    assert isinstance(to_offset("2H"), Hour)
    with pytest.raises(ValueError):
        to_offset("invalid_freq")


def test_to_cftime_datetime():
    if cftime is not None:
        date_str = "2000-01-01"
        assert isinstance(to_cftime_datetime(date_str, "noleap"), cftime.DatetimeNoLeap)
        with pytest.raises(ValueError):
            to_cftime_datetime(date_str)


def test_cftime_range():
    if cftime is not None:
        index = cftime_range(start="2000-01-01", periods=3, freq="D", calendar="noleap")
        assert len(index) == 3
        assert index[0] == cftime.DatetimeNoLeap(2000, 1, 1)


def test_date_range():
    index = date_range(start="2000-01-01", periods=3, freq="D", calendar="standard")
    assert len(index) == 3
    assert index[0] == pd.Timestamp("2000-01-01")


def test_date_range_like():
    source = pd.date_range(start="2000-01-01", periods=3, freq="D")
    result = date_range_like(source, calendar="noleap", use_cftime=True)
    assert len(result) == 3
    assert isinstance(result[0], cftime.DatetimeNoLeap)

Coverage: 65.13157894736842
Mutation Score: 33.379999999999995

Approach:
Predicted Test Suite: import pytest
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
from xarray.coding.cftime_offsets import (
    _MONTH_ABBREVIATIONS,
    BaseCFTimeOffset,
    Day,
    Hour,
    Microsecond,
    Millisecond,
    Minute,
    MonthBegin,
    MonthEnd,
    QuarterBegin,
    QuarterEnd,
    Second,
    Tick,
    YearBegin,
    YearEnd,
    _days_in_month,
    cftime_range,
    date_range,
    date_range_like,
    get_date_type,
    to_cftime_datetime,
    to_offset,
)

try:
    import cftime
except ImportError:
    cftime = None


def test_get_date_type():
    if cftime is not None:
        assert get_date_type("noleap") == cftime.DatetimeNoLeap
        assert get_date_type("360_day") == cftime.Datetime360Day
        assert get_date_type("gregorian", use_cftime=False) == pd.Timestamp
        with pytest.raises(KeyError):
            get_date_type("unknown_calendar")


def test_BaseCFTimeOffset_init():
    offset = BaseCFTimeOffset(2)
    assert offset.n == 2
    with pytest.raises(TypeError):
        BaseCFTimeOffset("not_an_int")


def test_BaseCFTimeOffset_eq():
    offset1 = BaseCFTimeOffset(2)
    offset2 = BaseCFTimeOffset(2)
    offset3 = BaseCFTimeOffset(3)
    assert offset1 == offset2
    assert offset1 != offset3


def test_BaseCFTimeOffset_add():
    offset = BaseCFTimeOffset(2)
    with pytest.raises(NotImplementedError):
        offset + 1


def test_BaseCFTimeOffset_sub():
    offset = BaseCFTimeOffset(2)
    with pytest.raises(NotImplementedError):
        offset - 1


def test_Tick_mul():
    tick = Day(1)
    assert tick * 2 == Day(2)
    assert 2 * tick == Day(2)
    with pytest.raises(NotImplementedError):
        tick * 2.5


def test_Tick_next_higher_resolution():
    tick = Day(1)
    assert tick._next_higher_resolution() == Hour(24)


def test_MonthBegin_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 1, 15)
        offset = MonthBegin(1)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2000, 2, 1)


def test_MonthEnd_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 1, 15)
        offset = MonthEnd(1)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2000, 1, 31)


def test_QuarterBegin_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 1, 15)
        offset = QuarterBegin(1, month=1)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2000, 4, 1)


def test_QuarterEnd_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 1, 15)
        offset = QuarterEnd(1, month=3)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2000, 3, 31)


def test_YearBegin_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 6, 15)
        offset = YearBegin(1, month=1)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2001, 1, 1)


def test_YearEnd_apply():
    if cftime is not None:
        date = cftime.DatetimeNoLeap(2000, 6, 15)
        offset = YearEnd(1, month=12)
        assert offset.__apply__(date) == cftime.DatetimeNoLeap(2000, 12, 31)


def test_to_offset():
    assert isinstance(to_offset("D"), Day)
    assert isinstance(to_offset("2H"), Hour)
    with pytest.raises(ValueError):
        to_offset("invalid_freq")


def test_to_cftime_datetime():
    if cftime is not None:
        date_str = "2000-01-01"
        assert isinstance(to_cftime_datetime(date_str, "noleap"), cftime.DatetimeNoLeap)
        with pytest.raises(ValueError):
            to_cftime_datetime(date_str)


def test_cftime_range():
    if cftime is not None:
        index = cftime_range(start="2000-01-01", periods=3, freq="D", calendar="noleap")
        assert len(index) == 3
        assert index[0] == cftime.DatetimeNoLeap(2000, 1, 1)


def test_date_range():
    index = date_range(start="2000-01-01", periods=3, freq="D", calendar="standard")
    assert len(index) == 3
    assert index[0] == pd.Timestamp("2000-01-01")


def test_date_range_like():
    source = pd.date_range(start="2000-01-01", periods=3, freq="D")
    result = date_range_like(source, calendar="noleap", use_cftime=True)
    assert len(result) == 3
    assert isinstance(result[0], cftime.DatetimeNoLeap)
Coverage: 65.13157894736842
Mutation Score: 35.989999999999995
Output: On branch main
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        deleted:    .coveragerc

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        xarray/tests/test_cftime_offsets.py

no changes added to commit (use "git add" and/or "git commit -a")
commit a31466ebe91dcfc2df850c80bf73fd22a5b2e34d
Author: TestGenEval <>
Date:   Wed Dec 11 12:52:58 2024 +0000

    Testing fixes

diff --git a/xarray/coding/cftime_offsets.py b/xarray/coding/cftime_offsets.py
index 30bfd882..a4e28706 100644
--- a/xarray/coding/cftime_offsets.py
+++ b/xarray/coding/cftime_offsets.py
@@ -39,11 +39,12 @@
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+from __future__ import annotations

 import re
 from datetime import datetime, timedelta
 from functools import partial
-from typing import ClassVar, Optional
+from typing import ClassVar

 import numpy as np
 import pandas as pd
@@ -87,10 +88,10 @@ def get_date_type(calendar, use_cftime=True):


 class BaseCFTimeOffset:
-    _freq: ClassVar[Optional[str]] = None
-    _day_option: ClassVar[Optional[str]] = None
+    _freq: ClassVar[str | None] = None
+    _day_option: ClassVar[str | None] = None

-    def __init__(self, n=1):
+    def __init__(self, n: int = 1):
         if not isinstance(n, int):
             raise TypeError(
                 "The provided multiple 'n' must be an integer. "
@@ -122,6 +123,8 @@ class BaseCFTimeOffset:
             return NotImplemented

     def __mul__(self, other):
+        if not isinstance(other, int):
+            return NotImplemented
         return type(self)(n=other * self.n)

     def __neg__(self):
@@ -171,6 +174,40 @@ class BaseCFTimeOffset:
         return _get_day_of_month(other, self._day_option)


+class Tick(BaseCFTimeOffset):
+    # analogous https://github.com/pandas-dev/pandas/blob/ccb25ab1d24c4fb9691270706a59c8d319750870/pandas/_libs/tslibs/offsets.pyx#L806
+
+    def _next_higher_resolution(self):
+        self_type = type(self)
+        if self_type not in [Day, Hour, Minute, Second, Millisecond]:
+            raise ValueError("Could not convert to integer offset at any resolution")
+        if type(self) is Day:
+            return Hour(self.n * 24)
+        if type(self) is Hour:
+            return Minute(self.n * 60)
+        if type(self) is Minute:
+            return Second(self.n * 60)
+        if type(self) is Second:
+            return Millisecond(self.n * 1000)
+        if type(self) is Millisecond:
+            return Microsecond(self.n * 1000)
+
+    def __mul__(self, other):
+        if not isinstance(other, (int, float)):
+            return NotImplemented
+        if isinstance(other, float):
+            n = other * self.n
+            # If the new `n` is an integer, we can represent it using the
+            #  same BaseCFTimeOffset subclass as self, otherwise we need to move up
+            #  to a higher-resolution subclass
+            if np.isclose(n % 1, 0):
+                return type(self)(int(n))
+
+            new_self = self._next_higher_resolution()
+            return new_self * other
+        return type(self)(n=other * self.n)
+
+
 def _get_day_of_month(other, day_option):
     """Find the day in `other`'s month that satisfies a BaseCFTimeOffset's
     onOffset policy, as described by the `day_option` argument.
@@ -396,6 +433,8 @@ class QuarterOffset(BaseCFTimeOffset):
             return NotImplemented

     def __mul__(self, other):
+        if isinstance(other, float):
+            return NotImplemented
         return type(self)(n=other * self.n, month=self.month)

     def rule_code(self):
@@ -482,6 +521,8 @@ class YearOffset(BaseCFTimeOffset):
             return NotImplemented

     def __mul__(self, other):
+        if isinstance(other, float):
+            return NotImplemented
         return type(self)(n=other * self.n, month=self.month)

     def rule_code(self):
@@ -541,7 +582,7 @@ class YearEnd(YearOffset):
             return date - YearEnd(month=self.month)


-class Day(BaseCFTimeOffset):
+class Day(Tick):
     _freq = "D"

     def as_timedelta(self):
@@ -551,7 +592,7 @@ class Day(BaseCFTimeOffset):
         return other + self.as_timedelta()


-class Hour(BaseCFTimeOffset):
+class Hour(Tick):
     _freq = "H"

     def as_timedelta(self):
@@ -561,7 +602,7 @@ class Hour(BaseCFTimeOffset):
         return other + self.as_timedelta()


-class Minute(BaseCFTimeOffset):
+class Minute(Tick):
     _freq = "T"

     def as_timedelta(self):
@@ -571,7 +612,7 @@ class Minute(BaseCFTimeOffset):
         return other + self.as_timedelta()


-class Second(BaseCFTimeOffset):
+class Second(Tick):
     _freq = "S"

     def as_timedelta(self):
@@ -581,7 +622,7 @@ class Second(BaseCFTimeOffset):
         return other + self.as_timedelta()


-class Millisecond(BaseCFTimeOffset):
+class Millisecond(Tick):
     _freq = "L"

     def as_timedelta(self):
@@ -591,7 +632,7 @@ class Millisecond(BaseCFTimeOffset):
         return other + self.as_timedelta()


-class Microsecond(BaseCFTimeOffset):
+class Microsecond(Tick):
     _freq = "U"

     def as_timedelta(self):
diff --git a/xarray/coding/cftimeindex.py b/xarray/coding/cftimeindex.py
index ac6904d4..20d5206b 100644
--- a/xarray/coding/cftimeindex.py
+++ b/xarray/coding/cftimeindex.py
@@ -38,11 +38,11 @@
 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+from __future__ import annotations

 import re
 import warnings
 from datetime import timedelta
-from typing import Tuple, Type

 import numpy as np
 import pandas as pd
@@ -66,7 +66,7 @@ ITEMS_IN_REPR_MAX_ELSE_ELLIPSIS = 100
 REPR_ELLIPSIS_SHOW_ITEMS_FRONT_END = 10


-OUT_OF_BOUNDS_TIMEDELTA_ERRORS: Tuple[Type[Exception], ...]
+OUT_OF_BOUNDS_TIMEDELTA_ERRORS: tuple[type[Exception], ...]
 try:
     OUT_OF_BOUNDS_TIMEDELTA_ERRORS = (pd.errors.OutOfBoundsTimedelta, OverflowError)
 except AttributeError:
@@ -511,7 +511,7 @@ class CFTimeIndex(pd.Index):
         """Needed for .loc based partial-string indexing"""
         return self.__contains__(key)

-    def shift(self, n, freq):
+    def shift(self, n: int | float, freq: str | timedelta):
         """Shift the CFTimeIndex a multiple of the given frequency.

         See the documentation for :py:func:`~xarray.cftime_range` for a
@@ -519,7 +519,7 @@ class CFTimeIndex(pd.Index):

         Parameters
         ----------
-        n : int
+        n : int, float if freq of days or below
             Periods to shift by
         freq : str or datetime.timedelta
             A frequency string or datetime.timedelta object to shift by
@@ -541,14 +541,15 @@ class CFTimeIndex(pd.Index):
         >>> index.shift(1, "M")
         CFTimeIndex([2000-02-29 00:00:00],
                     dtype='object', length=1, calendar='standard', freq=None)
+        >>> index.shift(1.5, "D")
+        CFTimeIndex([2000-02-01 12:00:00],
+                    dtype='object', length=1, calendar='standard', freq=None)
         """
-        from .cftime_offsets import to_offset
-
-        if not isinstance(n, int):
-            raise TypeError(f"'n' must be an int, got {n}.")
         if isinstance(freq, timedelta):
             return self + n * freq
         elif isinstance(freq, str):
+            from .cftime_offsets import to_offset
+
             return self + n * to_offset(freq)
         else:
             raise TypeError(
diff --git a/xarray/tests/test_cftime_offsets.py b/xarray/tests/test_cftime_offsets.py
deleted file mode 100644
index 4f94b35e..00000000
--- a/xarray/tests/test_cftime_offsets.py
+++ /dev/null
@@ -1,1327 +0,0 @@
-from itertools import product
-
-import numpy as np
-import pandas as pd
-import pytest
-
-from xarray import CFTimeIndex
-from xarray.coding.cftime_offsets import (
-    _MONTH_ABBREVIATIONS,
-    BaseCFTimeOffset,
-    Day,
-    Hour,
-    Microsecond,
-    Millisecond,
-    Minute,
-    MonthBegin,
-    MonthEnd,
-    QuarterBegin,
-    QuarterEnd,
-    Second,
-    YearBegin,
-    YearEnd,
-    _days_in_month,
-    cftime_range,
-    date_range,
-    date_range_like,
-    get_date_type,
-    to_cftime_datetime,
-    to_offset,
-)
-from xarray.coding.frequencies import infer_freq
-from xarray.core.dataarray import DataArray
-
-from . import _CFTIME_CALENDARS, requires_cftime
-
-cftime = pytest.importorskip("cftime")
-
-
-def _id_func(param):
-    """Called on each parameter passed to pytest.mark.parametrize"""
-    return str(param)
-
-
-@pytest.fixture(params=_CFTIME_CALENDARS)
-def calendar(request):
-    return request.param
-
-
-@pytest.mark.parametrize(
-    ("offset", "expected_n"),
-    [
-        (BaseCFTimeOffset(), 1),
-        (YearBegin(), 1),
-        (YearEnd(), 1),
-        (QuarterBegin(), 1),
-        (QuarterEnd(), 1),
-        (BaseCFTimeOffset(n=2), 2),
-        (YearBegin(n=2), 2),
-        (YearEnd(n=2), 2),
-        (QuarterBegin(n=2), 2),
-        (QuarterEnd(n=2), 2),
-    ],
-    ids=_id_func,
-)
-def test_cftime_offset_constructor_valid_n(offset, expected_n):
-    assert offset.n == expected_n
-
-
-@pytest.mark.parametrize(
-    ("offset", "invalid_n"),
-    [
-        (BaseCFTimeOffset, 1.5),
-        (YearBegin, 1.5),
-        (YearEnd, 1.5),
-        (QuarterBegin, 1.5),
-        (QuarterEnd, 1.5),
-    ],
-    ids=_id_func,
-)
-def test_cftime_offset_constructor_invalid_n(offset, invalid_n):
-    with pytest.raises(TypeError):
-        offset(n=invalid_n)
-
-
-@pytest.mark.parametrize(
-    ("offset", "expected_month"),
-    [
-        (YearBegin(), 1),
-        (YearEnd(), 12),
-        (YearBegin(month=5), 5),
-        (YearEnd(month=5), 5),
-        (QuarterBegin(), 3),
-        (QuarterEnd(), 3),
-        (QuarterBegin(month=5), 5),
-        (QuarterEnd(month=5), 5),
-    ],
-    ids=_id_func,
-)
-def test_year_offset_constructor_valid_month(offset, expected_month):
-    assert offset.month == expected_month
-
-
-@pytest.mark.parametrize(
-    ("offset", "invalid_month", "exception"),
-    [
-        (YearBegin, 0, ValueError),
-        (YearEnd, 0, ValueError),
-        (YearBegin, 13, ValueError),
-        (YearEnd, 13, ValueError),
-        (YearBegin, 1.5, TypeError),
-        (YearEnd, 1.5, TypeError),
-        (QuarterBegin, 0, ValueError),
-        (QuarterEnd, 0, ValueError),
-        (QuarterBegin, 1.5, TypeError),
-        (QuarterEnd, 1.5, TypeError),
-        (QuarterBegin, 13, ValueError),
-        (QuarterEnd, 13, ValueError),
-    ],
-    ids=_id_func,
-)
-def test_year_offset_constructor_invalid_month(offset, invalid_month, exception):
-    with pytest.raises(exception):
-        offset(month=invalid_month)
-
-
-@pytest.mark.parametrize(
-    ("offset", "expected"),
-    [
-        (BaseCFTimeOffset(), None),
-        (MonthBegin(), "MS"),
-        (YearBegin(), "AS-JAN"),
-        (QuarterBegin(), "QS-MAR"),
-    ],
-    ids=_id_func,
-)
-def test_rule_code(offset, expected):
-    assert offset.rule_code() == expected
-
-
-@pytest.mark.parametrize(
-    ("offset", "expected"),
-    [
-        (BaseCFTimeOffset(), "<BaseCFTimeOffset: n=1>"),
-        (YearBegin(), "<YearBegin: n=1, month=1>"),
-        (QuarterBegin(), "<QuarterBegin: n=1, month=3>"),
-    ],
-    ids=_id_func,
-)
-def test_str_and_repr(offset, expected):
-    assert str(offset) == expected
-    assert repr(offset) == expected
-
-
-@pytest.mark.parametrize(
-    "offset",
-    [BaseCFTimeOffset(), MonthBegin(), QuarterBegin(), YearBegin()],
-    ids=_id_func,
-)
-def test_to_offset_offset_input(offset):
-    assert to_offset(offset) == offset
-
-
-@pytest.mark.parametrize(
-    ("freq", "expected"),
-    [
-        ("M", MonthEnd()),
-        ("2M", MonthEnd(n=2)),
-        ("MS", MonthBegin()),
-        ("2MS", MonthBegin(n=2)),
-        ("D", Day()),
-        ("2D", Day(n=2)),
-        ("H", Hour()),
-        ("2H", Hour(n=2)),
-        ("T", Minute()),
-        ("2T", Minute(n=2)),
-        ("min", Minute()),
-        ("2min", Minute(n=2)),
-        ("S", Second()),
-        ("2S", Second(n=2)),
-        ("L", Millisecond(n=1)),
-        ("2L", Millisecond(n=2)),
-        ("ms", Millisecond(n=1)),
-        ("2ms", Millisecond(n=2)),
-        ("U", Microsecond(n=1)),
-        ("2U", Microsecond(n=2)),
-        ("us", Microsecond(n=1)),
-        ("2us", Microsecond(n=2)),
-    ],
-    ids=_id_func,
-)
-def test_to_offset_sub_annual(freq, expected):
-    assert to_offset(freq) == expected
-
-
-_ANNUAL_OFFSET_TYPES = {"A": YearEnd, "AS": YearBegin}
-
-
-@pytest.mark.parametrize(
-    ("month_int", "month_label"), list(_MONTH_ABBREVIATIONS.items()) + [(0, "")]
-)
-@pytest.mark.parametrize("multiple", [None, 2])
-@pytest.mark.parametrize("offset_str", ["AS", "A"])
-def test_to_offset_annual(month_label, month_int, multiple, offset_str):
-    freq = offset_str
-    offset_type = _ANNUAL_OFFSET_TYPES[offset_str]
-    if month_label:
-        freq = "-".join([freq, month_label])
-    if multiple:
-        freq = f"{multiple}{freq}"
-    result = to_offset(freq)
-
-    if multiple and month_int:
-        expected = offset_type(n=multiple, month=month_int)
-    elif multiple:
-        expected = offset_type(n=multiple)
-    elif month_int:
-        expected = offset_type(month=month_int)
-    else:
-        expected = offset_type()
-    assert result == expected
-
-
-_QUARTER_OFFSET_TYPES = {"Q": QuarterEnd, "QS": QuarterBegin}
-
-
-@pytest.mark.parametrize(
-    ("month_int", "month_label"), list(_MONTH_ABBREVIATIONS.items()) + [(0, "")]
-)
-@pytest.mark.parametrize("multiple", [None, 2])
-@pytest.mark.parametrize("offset_str", ["QS", "Q"])
-def test_to_offset_quarter(month_label, month_int, multiple, offset_str):
-    freq = offset_str
-    offset_type = _QUARTER_OFFSET_TYPES[offset_str]
-    if month_label:
-        freq = "-".join([freq, month_label])
-    if multiple:
-        freq = f"{multiple}{freq}"
-    result = to_offset(freq)
-
-    if multiple and month_int:
-        expected = offset_type(n=multiple, month=month_int)
-    elif multiple:
-        if month_int:
-            expected = offset_type(n=multiple)
-        else:
-            if offset_type == QuarterBegin:
-                expected = offset_type(n=multiple, month=1)
-            elif offset_type == QuarterEnd:
-                expected = offset_type(n=multiple, month=12)
-    elif month_int:
-        expected = offset_type(month=month_int)
-    else:
-        if offset_type == QuarterBegin:
-            expected = offset_type(month=1)
-        elif offset_type == QuarterEnd:
-            expected = offset_type(month=12)
-    assert result == expected
-
-
-@pytest.mark.parametrize("freq", ["Z", "7min2", "AM", "M-", "AS-", "QS-", "1H1min"])
-def test_invalid_to_offset_str(freq):
-    with pytest.raises(ValueError):
-        to_offset(freq)
-
-
-@pytest.mark.parametrize(
-    ("argument", "expected_date_args"),
-    [("2000-01-01", (2000, 1, 1)), ((2000, 1, 1), (2000, 1, 1))],
-    ids=_id_func,
-)
-def test_to_cftime_datetime(calendar, argument, expected_date_args):
-    date_type = get_date_type(calendar)
-    expected = date_type(*expected_date_args)
-    if isinstance(argument, tuple):
-        argument = date_type(*argument)
-    result = to_cftime_datetime(argument, calendar=calendar)
-    assert result == expected
-
-
-def test_to_cftime_datetime_error_no_calendar():
-    with pytest.raises(ValueError):
-        to_cftime_datetime("2000")
-
-
-def test_to_cftime_datetime_error_type_error():
-    with pytest.raises(TypeError):
-        to_cftime_datetime(1)
-
-
-_EQ_TESTS_A = [
-    BaseCFTimeOffset(),
-    YearBegin(),
-    YearEnd(),
-    YearBegin(month=2),
-    YearEnd(month=2),
-    QuarterBegin(),
-    QuarterEnd(),
-    QuarterBegin(month=2),
-    QuarterEnd(month=2),
-    MonthBegin(),
-    MonthEnd(),
-    Day(),
-    Hour(),
-    Minute(),
-    Second(),
-    Millisecond(),
-    Microsecond(),
-]
-_EQ_TESTS_B = [
-    BaseCFTimeOffset(n=2),
-    YearBegin(n=2),
-    YearEnd(n=2),
-    YearBegin(n=2, month=2),
-    YearEnd(n=2, month=2),
-    QuarterBegin(n=2),
-    QuarterEnd(n=2),
-    QuarterBegin(n=2, month=2),
-    QuarterEnd(n=2, month=2),
-    MonthBegin(n=2),
-    MonthEnd(n=2),
-    Day(n=2),
-    Hour(n=2),
-    Minute(n=2),
-    Second(n=2),
-    Millisecond(n=2),
-    Microsecond(n=2),
-]
-
-
-@pytest.mark.parametrize(("a", "b"), product(_EQ_TESTS_A, _EQ_TESTS_B), ids=_id_func)
-def test_neq(a, b):
-    assert a != b
-
-
-_EQ_TESTS_B_COPY = [
-    BaseCFTimeOffset(n=2),
-    YearBegin(n=2),
-    YearEnd(n=2),
-    YearBegin(n=2, month=2),
-    YearEnd(n=2, month=2),
-    QuarterBegin(n=2),
-    QuarterEnd(n=2),
-    QuarterBegin(n=2, month=2),
-    QuarterEnd(n=2, month=2),
-    MonthBegin(n=2),
-    MonthEnd(n=2),
-    Day(n=2),
-    Hour(n=2),
-    Minute(n=2),
-    Second(n=2),
-    Millisecond(n=2),
-    Microsecond(n=2),
-]
-
-
-@pytest.mark.parametrize(("a", "b"), zip(_EQ_TESTS_B, _EQ_TESTS_B_COPY), ids=_id_func)
-def test_eq(a, b):
-    assert a == b
-
-
-_MUL_TESTS = [
-    (BaseCFTimeOffset(), BaseCFTimeOffset(n=3)),
-    (YearEnd(), YearEnd(n=3)),
-    (YearBegin(), YearBegin(n=3)),
-    (QuarterEnd(), QuarterEnd(n=3)),
-    (QuarterBegin(), QuarterBegin(n=3)),
-    (MonthEnd(), MonthEnd(n=3)),
-    (MonthBegin(), MonthBegin(n=3)),
-    (Day(), Day(n=3)),
-    (Hour(), Hour(n=3)),
-    (Minute(), Minute(n=3)),
-    (Second(), Second(n=3)),
-    (Millisecond(), Millisecond(n=3)),
-    (Microsecond(), Microsecond(n=3)),
-]
-
-
-@pytest.mark.parametrize(("offset", "expected"), _MUL_TESTS, ids=_id_func)
-def test_mul(offset, expected):
-    assert offset * 3 == expected
-
-
-@pytest.mark.parametrize(("offset", "expected"), _MUL_TESTS, ids=_id_func)
-def test_rmul(offset, expected):
-    assert 3 * offset == expected
-
-
-@pytest.mark.parametrize(
-    ("offset", "expected"),
-    [
-        (BaseCFTimeOffset(), BaseCFTimeOffset(n=-1)),
-        (YearEnd(), YearEnd(n=-1)),
-        (YearBegin(), YearBegin(n=-1)),
-        (QuarterEnd(), QuarterEnd(n=-1)),
-        (QuarterBegin(), QuarterBegin(n=-1)),
-        (MonthEnd(), MonthEnd(n=-1)),
-        (MonthBegin(), MonthBegin(n=-1)),
-        (Day(), Day(n=-1)),
-        (Hour(), Hour(n=-1)),
-        (Minute(), Minute(n=-1)),
-        (Second(), Second(n=-1)),
-        (Millisecond(), Millisecond(n=-1)),
-        (Microsecond(), Microsecond(n=-1)),
-    ],
-    ids=_id_func,
-)
-def test_neg(offset, expected):
-    assert -offset == expected
-
-
-_ADD_TESTS = [
-    (Day(n=2), (1, 1, 3)),
-    (Hour(n=2), (1, 1, 1, 2)),
-    (Minute(n=2), (1, 1, 1, 0, 2)),
-    (Second(n=2), (1, 1, 1, 0, 0, 2)),
-    (Millisecond(n=2), (1, 1, 1, 0, 0, 0, 2000)),
-    (Microsecond(n=2), (1, 1, 1, 0, 0, 0, 2)),
-]
-
-
-@pytest.mark.parametrize(("offset", "expected_date_args"), _ADD_TESTS, ids=_id_func)
-def test_add_sub_monthly(offset, expected_date_args, calendar):
-    date_type = get_date_type(calendar)
-    initial = date_type(1, 1, 1)
-    expected = date_type(*expected_date_args)
-    result = offset + initial
-    assert result == expected
-
-
-@pytest.mark.parametrize(("offset", "expected_date_args"), _ADD_TESTS, ids=_id_func)
-def test_radd_sub_monthly(offset, expected_date_args, calendar):
-    date_type = get_date_type(calendar)
-    initial = date_type(1, 1, 1)
-    expected = date_type(*expected_date_args)
-    result = initial + offset
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    ("offset", "expected_date_args"),
-    [
-        (Day(n=2), (1, 1, 1)),
-        (Hour(n=2), (1, 1, 2, 22)),
-        (Minute(n=2), (1, 1, 2, 23, 58)),
-        (Second(n=2), (1, 1, 2, 23, 59, 58)),
-        (Millisecond(n=2), (1, 1, 2, 23, 59, 59, 998000)),
-        (Microsecond(n=2), (1, 1, 2, 23, 59, 59, 999998)),
-    ],
-    ids=_id_func,
-)
-def test_rsub_sub_monthly(offset, expected_date_args, calendar):
-    date_type = get_date_type(calendar)
-    initial = date_type(1, 1, 3)
-    expected = date_type(*expected_date_args)
-    result = initial - offset
-    assert result == expected
-
-
-@pytest.mark.parametrize("offset", _EQ_TESTS_A, ids=_id_func)
-def test_sub_error(offset, calendar):
-    date_type = get_date_type(calendar)
-    initial = date_type(1, 1, 1)
-    with pytest.raises(TypeError):
-        offset - initial
-
-
-@pytest.mark.parametrize(("a", "b"), zip(_EQ_TESTS_A, _EQ_TESTS_B), ids=_id_func)
-def test_minus_offset(a, b):
-    result = b - a
-    expected = a
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    ("a", "b"),
-    list(zip(np.roll(_EQ_TESTS_A, 1), _EQ_TESTS_B))  # type: ignore[arg-type]
-    + [(YearEnd(month=1), YearEnd(month=2))],
-    ids=_id_func,
-)
-def test_minus_offset_error(a, b):
-    with pytest.raises(TypeError):
-        b - a
-
-
-def test_days_in_month_non_december(calendar):
-    date_type = get_date_type(calendar)
-    reference = date_type(1, 4, 1)
-    assert _days_in_month(reference) == 30
-
-
-def test_days_in_month_december(calendar):
-    if calendar == "360_day":
-        expected = 30
-    else:
-        expected = 31
-    date_type = get_date_type(calendar)
-    reference = date_type(1, 12, 5)
-    assert _days_in_month(reference) == expected
-
-
-@pytest.mark.parametrize(
-    ("initial_date_args", "offset", "expected_date_args"),
-    [
-        ((1, 1, 1), MonthBegin(), (1, 2, 1)),
-        ((1, 1, 1), MonthBegin(n=2), (1, 3, 1)),
-        ((1, 1, 7), MonthBegin(), (1, 2, 1)),
-        ((1, 1, 7), MonthBegin(n=2), (1, 3, 1)),
-        ((1, 3, 1), MonthBegin(n=-1), (1, 2, 1)),
-        ((1, 3, 1), MonthBegin(n=-2), (1, 1, 1)),
-        ((1, 3, 3), MonthBegin(n=-1), (1, 3, 1)),
-        ((1, 3, 3), MonthBegin(n=-2), (1, 2, 1)),
-        ((1, 2, 1), MonthBegin(n=14), (2, 4, 1)),
-        ((2, 4, 1), MonthBegin(n=-14), (1, 2, 1)),
-        ((1, 1, 1, 5, 5, 5, 5), MonthBegin(), (1, 2, 1, 5, 5, 5, 5)),
-        ((1, 1, 3, 5, 5, 5, 5), MonthBegin(), (1, 2, 1, 5, 5, 5, 5)),
-        ((1, 1, 3, 5, 5, 5, 5), MonthBegin(n=-1), (1, 1, 1, 5, 5, 5, 5)),
-    ],
-    ids=_id_func,
-)
-def test_add_month_begin(calendar, initial_date_args, offset, expected_date_args):
-    date_type = get_date_type(calendar)
-    initial = date_type(*initial_date_args)
-    result = initial + offset
-    expected = date_type(*expected_date_args)
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    ("initial_date_args", "offset", "expected_year_month", "expected_sub_day"),
-    [
-        ((1, 1, 1), MonthEnd(), (1, 1), ()),
-        ((1, 1, 1), MonthEnd(n=2), (1, 2), ()),
-        ((1, 3, 1), MonthEnd(n=-1), (1, 2), ()),
-        ((1, 3, 1), MonthEnd(n=-2), (1, 1), ()),
-        ((1, 2, 1), MonthEnd(n=14), (2, 3), ()),
-        ((2, 4, 1), MonthEnd(n=-14), (1, 2), ()),
-        ((1, 1, 1, 5, 5, 5, 5), MonthEnd(), (1, 1), (5, 5, 5, 5)),
-        ((1, 2, 1, 5, 5, 5, 5), MonthEnd(n=-1), (1, 1), (5, 5, 5, 5)),
-    ],
-    ids=_id_func,
-)
-def test_add_month_end(
-    calendar, initial_date_args, offset, expected_year_month, expected_sub_day
-):
-    date_type = get_date_type(calendar)
-    initial = date_type(*initial_date_args)
-    result = initial + offset
-    reference_args = expected_year_month + (1,)
-    reference = date_type(*reference_args)
-
-    # Here the days at the end of each month varies based on the calendar used
-    expected_date_args = (
-        expected_year_month + (_days_in_month(reference),) + expected_sub_day
-    )
-    expected = date_type(*expected_date_args)
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    (
-        "initial_year_month",
-        "initial_sub_day",
-        "offset",
-        "expected_year_month",
-        "expected_sub_day",
-    ),
-    [
-        ((1, 1), (), MonthEnd(), (1, 2), ()),
-        ((1, 1), (), MonthEnd(n=2), (1, 3), ()),
-        ((1, 3), (), MonthEnd(n=-1), (1, 2), ()),
-        ((1, 3), (), MonthEnd(n=-2), (1, 1), ()),
-        ((1, 2), (), MonthEnd(n=14), (2, 4), ()),
-        ((2, 4), (), MonthEnd(n=-14), (1, 2), ()),
-        ((1, 1), (5, 5, 5, 5), MonthEnd(), (1, 2), (5, 5, 5, 5)),
-        ((1, 2), (5, 5, 5, 5), MonthEnd(n=-1), (1, 1), (5, 5, 5, 5)),
-    ],
-    ids=_id_func,
-)
-def test_add_month_end_onOffset(
-    calendar,
-    initial_year_month,
-    initial_sub_day,
-    offset,
-    expected_year_month,
-    expected_sub_day,
-):
-    date_type = get_date_type(calendar)
-    reference_args = initial_year_month + (1,)
-    reference = date_type(*reference_args)
-    initial_date_args = (
-        initial_year_month + (_days_in_month(reference),) + initial_sub_day
-    )
-    initial = date_type(*initial_date_args)
-    result = initial + offset
-    reference_args = expected_year_month + (1,)
-    reference = date_type(*reference_args)
-
-    # Here the days at the end of each month varies based on the calendar used
-    expected_date_args = (
-        expected_year_month + (_days_in_month(reference),) + expected_sub_day
-    )
-    expected = date_type(*expected_date_args)
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    ("initial_date_args", "offset", "expected_date_args"),
-    [
-        ((1, 1, 1), YearBegin(), (2, 1, 1)),
-        ((1, 1, 1), YearBegin(n=2), (3, 1, 1)),
-        ((1, 1, 1), YearBegin(month=2), (1, 2, 1)),
-        ((1, 1, 7), YearBegin(n=2), (3, 1, 1)),
-        ((2, 2, 1), YearBegin(n=-1), (2, 1, 1)),
-        ((1, 1, 2), YearBegin(n=-1), (1, 1, 1)),
-        ((1, 1, 1, 5, 5, 5, 5), YearBegin(), (2, 1, 1, 5, 5, 5, 5)),
-        ((2, 1, 1, 5, 5, 5, 5), YearBegin(n=-1), (1, 1, 1, 5, 5, 5, 5)),
-    ],
-    ids=_id_func,
-)
-def test_add_year_begin(calendar, initial_date_args, offset, expected_date_args):
-    date_type = get_date_type(calendar)
-    initial = date_type(*initial_date_args)
-    result = initial + offset
-    expected = date_type(*expected_date_args)
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    ("initial_date_args", "offset", "expected_year_month", "expected_sub_day"),
-    [
-        ((1, 1, 1), YearEnd(), (1, 12), ()),
-        ((1, 1, 1), YearEnd(n=2), (2, 12), ()),
-        ((1, 1, 1), YearEnd(month=1), (1, 1), ()),
-        ((2, 3, 1), YearEnd(n=-1), (1, 12), ()),
-        ((1, 3, 1), YearEnd(n=-1, month=2), (1, 2), ()),
-        ((1, 1, 1, 5, 5, 5, 5), YearEnd(), (1, 12), (5, 5, 5, 5)),
-        ((1, 1, 1, 5, 5, 5, 5), YearEnd(n=2), (2, 12), (5, 5, 5, 5)),
-    ],
-    ids=_id_func,
-)
-def test_add_year_end(
-    calendar, initial_date_args, offset, expected_year_month, expected_sub_day
-):
-    date_type = get_date_type(calendar)
-    initial = date_type(*initial_date_args)
-    result = initial + offset
-    reference_args = expected_year_month + (1,)
-    reference = date_type(*reference_args)
-
-    # Here the days at the end of each month varies based on the calendar used
-    expected_date_args = (
-        expected_year_month + (_days_in_month(reference),) + expected_sub_day
-    )
-    expected = date_type(*expected_date_args)
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    (
-        "initial_year_month",
-        "initial_sub_day",
-        "offset",
-        "expected_year_month",
-        "expected_sub_day",
-    ),
-    [
-        ((1, 12), (), YearEnd(), (2, 12), ()),
-        ((1, 12), (), YearEnd(n=2), (3, 12), ()),
-        ((2, 12), (), YearEnd(n=-1), (1, 12), ()),
-        ((3, 12), (), YearEnd(n=-2), (1, 12), ()),
-        ((1, 1), (), YearEnd(month=2), (1, 2), ()),
-        ((1, 12), (5, 5, 5, 5), YearEnd(), (2, 12), (5, 5, 5, 5)),
-        ((2, 12), (5, 5, 5, 5), YearEnd(n=-1), (1, 12), (5, 5, 5, 5)),
-    ],
-    ids=_id_func,
-)
-def test_add_year_end_onOffset(
-    calendar,
-    initial_year_month,
-    initial_sub_day,
-    offset,
-    expected_year_month,
-    expected_sub_day,
-):
-    date_type = get_date_type(calendar)
-    reference_args = initial_year_month + (1,)
-    reference = date_type(*reference_args)
-    initial_date_args = (
-        initial_year_month + (_days_in_month(reference),) + initial_sub_day
-    )
-    initial = date_type(*initial_date_args)
-    result = initial + offset
-    reference_args = expected_year_month + (1,)
-    reference = date_type(*reference_args)
-
-    # Here the days at the end of each month varies based on the calendar used
-    expected_date_args = (
-        expected_year_month + (_days_in_month(reference),) + expected_sub_day
-    )
-    expected = date_type(*expected_date_args)
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    ("initial_date_args", "offset", "expected_date_args"),
-    [
-        ((1, 1, 1), QuarterBegin(), (1, 3, 1)),
-        ((1, 1, 1), QuarterBegin(n=2), (1, 6, 1)),
-        ((1, 1, 1), QuarterBegin(month=2), (1, 2, 1)),
-        ((1, 1, 7), QuarterBegin(n=2), (1, 6, 1)),
-        ((2, 2, 1), QuarterBegin(n=-1), (1, 12, 1)),
-        ((1, 3, 2), QuarterBegin(n=-1), (1, 3, 1)),
-        ((1, 1, 1, 5, 5, 5, 5), QuarterBegin(), (1, 3, 1, 5, 5, 5, 5)),
-        ((2, 1, 1, 5, 5, 5, 5), QuarterBegin(n=-1), (1, 12, 1, 5, 5, 5, 5)),
-    ],
-    ids=_id_func,
-)
-def test_add_quarter_begin(calendar, initial_date_args, offset, expected_date_args):
-    date_type = get_date_type(calendar)
-    initial = date_type(*initial_date_args)
-    result = initial + offset
-    expected = date_type(*expected_date_args)
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    ("initial_date_args", "offset", "expected_year_month", "expected_sub_day"),
-    [
-        ((1, 1, 1), QuarterEnd(), (1, 3), ()),
-        ((1, 1, 1), QuarterEnd(n=2), (1, 6), ()),
-        ((1, 1, 1), QuarterEnd(month=1), (1, 1), ()),
-        ((2, 3, 1), QuarterEnd(n=-1), (1, 12), ()),
-        ((1, 3, 1), QuarterEnd(n=-1, month=2), (1, 2), ()),
-        ((1, 1, 1, 5, 5, 5, 5), QuarterEnd(), (1, 3), (5, 5, 5, 5)),
-        ((1, 1, 1, 5, 5, 5, 5), QuarterEnd(n=2), (1, 6), (5, 5, 5, 5)),
-    ],
-    ids=_id_func,
-)
-def test_add_quarter_end(
-    calendar, initial_date_args, offset, expected_year_month, expected_sub_day
-):
-    date_type = get_date_type(calendar)
-    initial = date_type(*initial_date_args)
-    result = initial + offset
-    reference_args = expected_year_month + (1,)
-    reference = date_type(*reference_args)
-
-    # Here the days at the end of each month varies based on the calendar used
-    expected_date_args = (
-        expected_year_month + (_days_in_month(reference),) + expected_sub_day
-    )
-    expected = date_type(*expected_date_args)
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    (
-        "initial_year_month",
-        "initial_sub_day",
-        "offset",
-        "expected_year_month",
-        "expected_sub_day",
-    ),
-    [
-        ((1, 12), (), QuarterEnd(), (2, 3), ()),
-        ((1, 12), (), QuarterEnd(n=2), (2, 6), ()),
-        ((1, 12), (), QuarterEnd(n=-1), (1, 9), ()),
-        ((1, 12), (), QuarterEnd(n=-2), (1, 6), ()),
-        ((1, 1), (), QuarterEnd(month=2), (1, 2), ()),
-        ((1, 12), (5, 5, 5, 5), QuarterEnd(), (2, 3), (5, 5, 5, 5)),
-        ((1, 12), (5, 5, 5, 5), QuarterEnd(n=-1), (1, 9), (5, 5, 5, 5)),
-    ],
-    ids=_id_func,
-)
-def test_add_quarter_end_onOffset(
-    calendar,
-    initial_year_month,
-    initial_sub_day,
-    offset,
-    expected_year_month,
-    expected_sub_day,
-):
-    date_type = get_date_type(calendar)
-    reference_args = initial_year_month + (1,)
-    reference = date_type(*reference_args)
-    initial_date_args = (
-        initial_year_month + (_days_in_month(reference),) + initial_sub_day
-    )
-    initial = date_type(*initial_date_args)
-    result = initial + offset
-    reference_args = expected_year_month + (1,)
-    reference = date_type(*reference_args)
-
-    # Here the days at the end of each month varies based on the calendar used
-    expected_date_args = (
-        expected_year_month + (_days_in_month(reference),) + expected_sub_day
-    )
-    expected = date_type(*expected_date_args)
-    assert result == expected
-
-
-# Note for all sub-monthly offsets, pandas always returns True for onOffset
-@pytest.mark.parametrize(
-    ("date_args", "offset", "expected"),
-    [
-        ((1, 1, 1), MonthBegin(), True),
-        ((1, 1, 1, 1), MonthBegin(), True),
-        ((1, 1, 5), MonthBegin(), False),
-        ((1, 1, 5), MonthEnd(), False),
-        ((1, 3, 1), QuarterBegin(), True),
-        ((1, 3, 1, 1), QuarterBegin(), True),
-        ((1, 3, 5), QuarterBegin(), False),
-        ((1, 12, 1), QuarterEnd(), False),
-        ((1, 1, 1), YearBegin(), True),
-        ((1, 1, 1, 1), YearBegin(), True),
-        ((1, 1, 5), YearBegin(), False),
-        ((1, 12, 1), YearEnd(), False),
-        ((1, 1, 1), Day(), True),
-        ((1, 1, 1, 1), Day(), True),
-        ((1, 1, 1), Hour(), True),
-        ((1, 1, 1), Minute(), True),
-        ((1, 1, 1), Second(), True),
-        ((1, 1, 1), Millisecond(), True),
-        ((1, 1, 1), Microsecond(), True),
-    ],
-    ids=_id_func,
-)
-def test_onOffset(calendar, date_args, offset, expected):
-    date_type = get_date_type(calendar)
-    date = date_type(*date_args)
-    result = offset.onOffset(date)
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    ("year_month_args", "sub_day_args", "offset"),
-    [
-        ((1, 1), (), MonthEnd()),
-        ((1, 1), (1,), MonthEnd()),
-        ((1, 12), (), QuarterEnd()),
-        ((1, 1), (), QuarterEnd(month=1)),
-        ((1, 12), (), YearEnd()),
-        ((1, 1), (), YearEnd(month=1)),
-    ],
-    ids=_id_func,
-)
-def test_onOffset_month_or_quarter_or_year_end(
-    calendar, year_month_args, sub_day_args, offset
-):
-    date_type = get_date_type(calendar)
-    reference_args = year_month_args + (1,)
-    reference = date_type(*reference_args)
-    date_args = year_month_args + (_days_in_month(reference),) + sub_day_args
-    date = date_type(*date_args)
-    result = offset.onOffset(date)
-    assert result
-
-
-@pytest.mark.parametrize(
-    ("offset", "initial_date_args", "partial_expected_date_args"),
-    [
-        (YearBegin(), (1, 3, 1), (2, 1)),
-        (YearBegin(), (1, 1, 1), (1, 1)),
-        (YearBegin(n=2), (1, 3, 1), (2, 1)),
-        (YearBegin(n=2, month=2), (1, 3, 1), (2, 2)),
-        (YearEnd(), (1, 3, 1), (1, 12)),
-        (YearEnd(n=2), (1, 3, 1), (1, 12)),
-        (YearEnd(n=2, month=2), (1, 3, 1), (2, 2)),
-        (YearEnd(n=2, month=4), (1, 4, 30), (1, 4)),
-        (QuarterBegin(), (1, 3, 2), (1, 6)),
-        (QuarterBegin(), (1, 4, 1), (1, 6)),
-        (QuarterBegin(n=2), (1, 4, 1), (1, 6)),
-        (QuarterBegin(n=2, month=2), (1, 4, 1), (1, 5)),
-        (QuarterEnd(), (1, 3, 1), (1, 3)),
-        (QuarterEnd(n=2), (1, 3, 1), (1, 3)),
-        (QuarterEnd(n=2, month=2), (1, 3, 1), (1, 5)),
-        (QuarterEnd(n=2, month=4), (1, 4, 30), (1, 4)),
-        (MonthBegin(), (1, 3, 2), (1, 4)),
-        (MonthBegin(), (1, 3, 1), (1, 3)),
-        (MonthBegin(n=2), (1, 3, 2), (1, 4)),
-        (MonthEnd(), (1, 3, 2), (1, 3)),
-        (MonthEnd(), (1, 4, 30), (1, 4)),
-        (MonthEnd(n=2), (1, 3, 2), (1, 3)),
-        (Day(), (1, 3, 2, 1), (1, 3, 2, 1)),
-        (Hour(), (1, 3, 2, 1, 1), (1, 3, 2, 1, 1)),
-        (Minute(), (1, 3, 2, 1, 1, 1), (1, 3, 2, 1, 1, 1)),
-        (Second(), (1, 3, 2, 1, 1, 1, 1), (1, 3, 2, 1, 1, 1, 1)),
-        (Millisecond(), (1, 3, 2, 1, 1, 1, 1000), (1, 3, 2, 1, 1, 1, 1000)),
-        (Microsecond(), (1, 3, 2, 1, 1, 1, 1), (1, 3, 2, 1, 1, 1, 1)),
-    ],
-    ids=_id_func,
-)
-def test_rollforward(calendar, offset, initial_date_args, partial_expected_date_args):
-    date_type = get_date_type(calendar)
-    initial = date_type(*initial_date_args)
-    if isinstance(offset, (MonthBegin, QuarterBegin, YearBegin)):
-        expected_date_args = partial_expected_date_args + (1,)
-    elif isinstance(offset, (MonthEnd, QuarterEnd, YearEnd)):
-        reference_args = partial_expected_date_args + (1,)
-        reference = date_type(*reference_args)
-        expected_date_args = partial_expected_date_args + (_days_in_month(reference),)
-    else:
-        expected_date_args = partial_expected_date_args
-    expected = date_type(*expected_date_args)
-    result = offset.rollforward(initial)
-    assert result == expected
-
-
-@pytest.mark.parametrize(
-    ("offset", "initial_date_args", "partial_expected_date_args"),
-    [
-        (YearBegin(), (1, 3, 1), (1, 1)),
-        (YearBegin(n=2), (1, 3, 1), (1, 1)),
-        (YearBegin(n=2, month=2), (1, 3, 1), (1, 2)),
-        (YearBegin(), (1, 1, 1), (1, 1)),
-        (YearBegin(n=2, month=2), (1, 2, 1), (1, 2)),
-        (YearEnd(), (2, 3, 1), (1, 12)),
-        (YearEnd(n=2), (2, 3, 1), (1, 12)),
-        (YearEnd(n=2, month=2), (2, 3, 1), (2, 2)),
-        (YearEnd(month=4), (1, 4, 30), (1, 4)),
-        (QuarterBegin(), (1, 3, 2), (1, 3)),
-        (QuarterBegin(), (1, 4, 1), (1, 3)),
-        (QuarterBegin(n=2), (1, 4, 1), (1, 3)),
-        (QuarterBegin(n=2, month=2), (1, 4, 1), (1, 2)),
-        (QuarterEnd(), (2, 3, 1), (1, 12)),
-        (QuarterEnd(n=2), (2, 3, 1), (1, 12)),
-        (QuarterEnd(n=2, month=2), (2, 3, 1), (2, 2)),
-        (QuarterEnd(n=2, month=4), (1, 4, 30), (1, 4)),
-        (MonthBegin(), (1, 3, 2), (1, 3)),
-        (MonthBegin(n=2), (1, 3, 2), (1, 3)),
-        (MonthBegin(), (1, 3, 1), (1, 3)),
-        (MonthEnd(), (1, 3, 2), (1, 2)),
-        (MonthEnd(n=2), (1, 3, 2), (1, 2)),
-        (MonthEnd(), (1, 4, 30), (1, 4)),
-        (Day(), (1, 3, 2, 1), (1, 3, 2, 1)),
-        (Hour(), (1, 3, 2, 1, 1), (1, 3, 2, 1, 1)),
-        (Minute(), (1, 3, 2, 1, 1, 1), (1, 3, 2, 1, 1, 1)),
-        (Second(), (1, 3, 2, 1, 1, 1, 1), (1, 3, 2, 1, 1, 1, 1)),
-        (Millisecond(), (1, 3, 2, 1, 1, 1, 1000), (1, 3, 2, 1, 1, 1, 1000)),
-        (Microsecond(), (1, 3, 2, 1, 1, 1, 1), (1, 3, 2, 1, 1, 1, 1)),
-    ],
-    ids=_id_func,
-)
-def test_rollback(calendar, offset, initial_date_args, partial_expected_date_args):
-    date_type = get_date_type(calendar)
-    initial = date_type(*initial_date_args)
-    if isinstance(offset, (MonthBegin, QuarterBegin, YearBegin)):
-        expected_date_args = partial_expected_date_args + (1,)
-    elif isinstance(offset, (MonthEnd, QuarterEnd, YearEnd)):
-        reference_args = partial_expected_date_args + (1,)
-        reference = date_type(*reference_args)
-        expected_date_args = partial_expected_date_args + (_days_in_month(reference),)
-    else:
-        expected_date_args = partial_expected_date_args
-    expected = date_type(*expected_date_args)
-    result = offset.rollback(initial)
-    assert result == expected
-
-
-_CFTIME_RANGE_TESTS = [
-    (
-        "0001-01-01",
-        "0001-01-04",
-        None,
-        "D",
-        None,
-        False,
-        [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4)],
-    ),
-    (
-        "0001-01-01",
-        "0001-01-04",
-        None,
-        "D",
-        "left",
-        False,
-        [(1, 1, 1), (1, 1, 2), (1, 1, 3)],
-    ),
-    (
-        "0001-01-01",
-        "0001-01-04",
-        None,
-        "D",
-        "right",
-        False,
-        [(1, 1, 2), (1, 1, 3), (1, 1, 4)],
-    ),
-    (
-        "0001-01-01T01:00:00",
-        "0001-01-04",
-        None,
-        "D",
-        None,
-        False,
-        [(1, 1, 1, 1), (1, 1, 2, 1), (1, 1, 3, 1)],
-    ),
-    (
-        "0001-01-01 01:00:00",
-        "0001-01-04",
-        None,
-        "D",
-        None,
-        False,
-        [(1, 1, 1, 1), (1, 1, 2, 1), (1, 1, 3, 1)],
-    ),
-    (
-        "0001-01-01T01:00:00",
-        "0001-01-04",
-        None,
-        "D",
-        None,
-        True,
-        [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4)],
-    ),
-    (
-        "0001-01-01",
-        None,
-        4,
-        "D",
-        None,
-        False,
-        [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4)],
-    ),
-    (
-        None,
-        "0001-01-04",
-        4,
-        "D",
-        None,
-        False,
-        [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4)],
-    ),
-    (
-        (1, 1, 1),
-        "0001-01-04",
-        None,
-        "D",
-        None,
-        False,
-        [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4)],
-    ),
-    (
-        (1, 1, 1),
-        (1, 1, 4),
-        None,
-        "D",
-        None,
-        False,
-        [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4)],
-    ),
-    (
-        "0001-01-30",
-        "0011-02-01",
-        None,
-        "3AS-JUN",
-        None,
-        False,
-        [(1, 6, 1), (4, 6, 1), (7, 6, 1), (10, 6, 1)],
-    ),
-    ("0001-01-04", "0001-01-01", None, "D", None, False, []),
-    (
-        "0010",
-        None,
-        4,
-        YearBegin(n=-2),
-        None,
-        False,
-        [(10, 1, 1), (8, 1, 1), (6, 1, 1), (4, 1, 1)],
-    ),
-    (
-        "0001-01-01",
-        "0001-01-04",
-        4,
-        None,
-        None,
-        False,
-        [(1, 1, 1), (1, 1, 2), (1, 1, 3), (1, 1, 4)],
-    ),
-    (
-        "0001-06-01",
-        None,
-        4,
-        "3QS-JUN",
-        None,
-        False,
-        [(1, 6, 1), (2, 3, 1), (2, 12, 1), (3, 9, 1)],
-    ),
-]
-
-
-@pytest.mark.parametrize(
-    ("start", "end", "periods", "freq", "closed", "normalize", "expected_date_args"),
-    _CFTIME_RANGE_TESTS,
-    ids=_id_func,
-)
-def test_cftime_range(
-    start, end, periods, freq, closed, normalize, calendar, expected_date_args
-):
-    date_type = get_date_type(calendar)
-    expected_dates = [date_type(*args) for args in expected_date_args]
-
-    if isinstance(start, tuple):
-        start = date_type(*start)
-    if isinstance(end, tuple):
-        end = date_type(*end)
-
-    result = cftime_range(
-        start=start,
-        end=end,
-        periods=periods,
-        freq=freq,
-        closed=closed,
-        normalize=normalize,
-        calendar=calendar,
-    )
-    resulting_dates = result.values
-
-    assert isinstance(result, CFTimeIndex)
-
-    if freq is not None:
-        np.testing.assert_equal(resulting_dates, expected_dates)
-    else:
-        # If we create a linear range of dates using cftime.num2date
-        # we will not get exact round number dates.  This is because
-        # datetime arithmetic in cftime is accurate approximately to
-        # 1 millisecond (see https://unidata.github.io/cftime/api.html).
-        deltas = resulting_dates - expected_dates
-        deltas = np.array([delta.total_seconds() for delta in deltas])
-        assert np.max(np.abs(deltas)) < 0.001
-
-
-def test_cftime_range_name():
-    result = cftime_range(start="2000", periods=4, name="foo")
-    assert result.name == "foo"
-
-    result = cftime_range(start="2000", periods=4)
-    assert result.name is None
-
-
-@pytest.mark.parametrize(
-    ("start", "end", "periods", "freq", "closed"),
-    [
-        (None, None, 5, "A", None),
-        ("2000", None, None, "A", None),
-        (None, "2000", None, "A", None),
-        ("2000", "2001", None, None, None),
-        (None, None, None, None, None),
-        ("2000", "2001", None, "A", "up"),
-        ("2000", "2001", 5, "A", None),
-    ],
-)
-def test_invalid_cftime_range_inputs(start, end, periods, freq, closed):
-    with pytest.raises(ValueError):
-        cftime_range(start, end, periods, freq, closed=closed)
-
-
-_CALENDAR_SPECIFIC_MONTH_END_TESTS = [
-    ("2M", "noleap", [(2, 28), (4, 30), (6, 30), (8, 31), (10, 31), (12, 31)]),
-    ("2M", "all_leap", [(2, 29), (4, 30), (6, 30), (8, 31), (10, 31), (12, 31)]),
-    ("2M", "360_day", [(2, 30), (4, 30), (6, 30), (8, 30), (10, 30), (12, 30)]),
-    ("2M", "standard", [(2, 29), (4, 30), (6, 30), (8, 31), (10, 31), (12, 31)]),
-    ("2M", "gregorian", [(2, 29), (4, 30), (6, 30), (8, 31), (10, 31), (12, 31)]),
-    ("2M", "julian", [(2, 29), (4, 30), (6, 30), (8, 31), (10, 31), (12, 31)]),
-]
-
-
-@pytest.mark.parametrize(
-    ("freq", "calendar", "expected_month_day"),
-    _CALENDAR_SPECIFIC_MONTH_END_TESTS,
-    ids=_id_func,
-)
-def test_calendar_specific_month_end(freq, calendar, expected_month_day):
-    year = 2000  # Use a leap-year to highlight calendar differences
-    result = cftime_range(
-        start="2000-02", end="2001", freq=freq, calendar=calendar
-    ).values
-    date_type = get_date_type(calendar)
-    expected = [date_type(year, *args) for args in expected_month_day]
-    np.testing.assert_equal(result, expected)
-
-
-@pytest.mark.parametrize(
-    ("calendar", "start", "end", "expected_number_of_days"),
-    [
-        ("noleap", "2000", "2001", 365),
-        ("all_leap", "2000", "2001", 366),
-        ("360_day", "2000", "2001", 360),
-        ("standard", "2000", "2001", 366),
-        ("gregorian", "2000", "2001", 366),
-        ("julian", "2000", "2001", 366),
-        ("noleap", "2001", "2002", 365),
-        ("all_leap", "2001", "2002", 366),
-        ("360_day", "2001", "2002", 360),
-        ("standard", "2001", "2002", 365),
-        ("gregorian", "2001", "2002", 365),
-        ("julian", "2001", "2002", 365),
-    ],
-)
-def test_calendar_year_length(calendar, start, end, expected_number_of_days):
-    result = cftime_range(start, end, freq="D", closed="left", calendar=calendar)
-    assert len(result) == expected_number_of_days
-
-
-@pytest.mark.parametrize("freq", ["A", "M", "D"])
-def test_dayofweek_after_cftime_range(freq):
-    result = cftime_range("2000-02-01", periods=3, freq=freq).dayofweek
-    expected = pd.date_range("2000-02-01", periods=3, freq=freq).dayofweek
-    np.testing.assert_array_equal(result, expected)
-
-
-@pytest.mark.parametrize("freq", ["A", "M", "D"])
-def test_dayofyear_after_cftime_range(freq):
-    result = cftime_range("2000-02-01", periods=3, freq=freq).dayofyear
-    expected = pd.date_range("2000-02-01", periods=3, freq=freq).dayofyear
-    np.testing.assert_array_equal(result, expected)
-
-
-def test_cftime_range_standard_calendar_refers_to_gregorian():
-    from cftime import DatetimeGregorian
-
-    (result,) = cftime_range("2000", periods=1)
-    assert isinstance(result, DatetimeGregorian)
-
-
-@pytest.mark.parametrize(
-    "start,calendar,use_cftime,expected_type",
-    [
-        ("1990-01-01", "standard", None, pd.DatetimeIndex),
-        ("1990-01-01", "proleptic_gregorian", True, CFTimeIndex),
-        ("1990-01-01", "noleap", None, CFTimeIndex),
-        ("1990-01-01", "gregorian", False, pd.DatetimeIndex),
-        ("1400-01-01", "standard", None, CFTimeIndex),
-        ("3400-01-01", "standard", None, CFTimeIndex),
-    ],
-)
-def test_date_range(start, calendar, use_cftime, expected_type):
-    dr = date_range(
-        start, periods=14, freq="D", calendar=calendar, use_cftime=use_cftime
-    )
-
-    assert isinstance(dr, expected_type)
-
-
-def test_date_range_errors():
-    with pytest.raises(ValueError, match="Date range is invalid"):
-        date_range(
-            "1400-01-01", periods=1, freq="D", calendar="standard", use_cftime=False
-        )
-
-    with pytest.raises(ValueError, match="Date range is invalid"):
-        date_range(
-            "2480-01-01",
-            periods=1,
-            freq="D",
-            calendar="proleptic_gregorian",
-            use_cftime=False,
-        )
-
-    with pytest.raises(ValueError, match="Invalid calendar "):
-        date_range(
-            "1900-01-01", periods=1, freq="D", calendar="noleap", use_cftime=False
-        )
-
-
-@requires_cftime
-@pytest.mark.parametrize(
-    "start,freq,cal_src,cal_tgt,use_cftime,exp0,exp_pd",
-    [
-        ("2020-02-01", "4M", "standard", "noleap", None, "2020-02-28", False),
-        ("2020-02-01", "M", "noleap", "gregorian", True, "2020-02-29", True),
-        ("2020-02-28", "3H", "all_leap", "gregorian", False, "2020-02-28", True),
-        ("2020-03-30", "M", "360_day", "gregorian", False, "2020-03-31", True),
-        ("2020-03-31", "M", "gregorian", "360_day", None, "2020-03-30", False),
-    ],
-)
-def test_date_range_like(start, freq, cal_src, cal_tgt, use_cftime, exp0, exp_pd):
-    source = date_range(start, periods=12, freq=freq, calendar=cal_src)
-
-    out = date_range_like(source, cal_tgt, use_cftime=use_cftime)
-
-    assert len(out) == 12
-    assert infer_freq(out) == freq
-
-    assert out[0].isoformat().startswith(exp0)
-
-    if exp_pd:
-        assert isinstance(out, pd.DatetimeIndex)
-    else:
-        assert isinstance(out, CFTimeIndex)
-        assert out.calendar == cal_tgt
-
-
-def test_date_range_like_same_calendar():
-    src = date_range("2000-01-01", periods=12, freq="6H", use_cftime=False)
-    out = date_range_like(src, "standard", use_cftime=False)
-    assert src is out
-
-
-def test_date_range_like_errors():
-    src = date_range("1899-02-03", periods=20, freq="D", use_cftime=False)
-    src = src[np.arange(20) != 10]  # Remove 1 day so the frequency is not inferrable.
-
-    with pytest.raises(
-        ValueError,
-        match="`date_range_like` was unable to generate a range as the source frequency was not inferrable.",
-    ):
-        date_range_like(src, "gregorian")
-
-    src = DataArray(
-        np.array(
-            [["1999-01-01", "1999-01-02"], ["1999-01-03", "1999-01-04"]],
-            dtype=np.datetime64,
-        ),
-        dims=("x", "y"),
-    )
-    with pytest.raises(
-        ValueError,
-        match="'source' must be a 1D array of datetime objects for inferring its range.",
-    ):
-        date_range_like(src, "noleap")
-
-    da = DataArray([1, 2, 3, 4], dims=("time",))
-    with pytest.raises(
-        ValueError,
-        match="'source' must be a 1D array of datetime objects for inferring its range.",
-    ):
-        date_range_like(da, "noleap")
diff --git a/xarray/tests/test_cftimeindex.py b/xarray/tests/test_cftimeindex.py
index 94f0cf4c..28f0ef49 100644
--- a/xarray/tests/test_cftimeindex.py
+++ b/xarray/tests/test_cftimeindex.py
@@ -754,7 +754,7 @@ def test_cftimeindex_add(index):

 @requires_cftime
 @pytest.mark.parametrize("calendar", _CFTIME_CALENDARS)
-def test_cftimeindex_add_timedeltaindex(calendar):
+def test_cftimeindex_add_timedeltaindex(calendar) -> None:
     a = xr.cftime_range("2000", periods=5, calendar=calendar)
     deltas = pd.TimedeltaIndex([timedelta(days=2) for _ in range(5)])
     result = a + deltas
@@ -763,6 +763,44 @@ def test_cftimeindex_add_timedeltaindex(calendar):
     assert isinstance(result, CFTimeIndex)


+@requires_cftime
+@pytest.mark.parametrize("n", [2.0, 1.5])
+@pytest.mark.parametrize(
+    "freq,units",
+    [
+        ("D", "D"),
+        ("H", "H"),
+        ("T", "min"),
+        ("S", "S"),
+        ("L", "ms"),
+    ],
+)
+@pytest.mark.parametrize("calendar", _CFTIME_CALENDARS)
+def test_cftimeindex_shift_float(n, freq, units, calendar) -> None:
+    a = xr.cftime_range("2000", periods=3, calendar=calendar, freq="D")
+    result = a + pd.Timedelta(n, units)
+    expected = a.shift(n, freq)
+    assert result.equals(expected)
+    assert isinstance(result, CFTimeIndex)
+
+
+@requires_cftime
+def test_cftimeindex_shift_float_us() -> None:
+    a = xr.cftime_range("2000", periods=3, freq="D")
+    with pytest.raises(
+        ValueError, match="Could not convert to integer offset at any resolution"
+    ):
+        a.shift(2.5, "us")
+
+
+@requires_cftime
+@pytest.mark.parametrize("freq", ["AS", "A", "YS", "Y", "QS", "Q", "MS", "M"])
+def test_cftimeindex_shift_float_fails_for_non_tick_freqs(freq) -> None:
+    a = xr.cftime_range("2000", periods=3, freq="D")
+    with pytest.raises(TypeError, match="unsupported operand type"):
+        a.shift(2.5, freq)
+
+
 @requires_cftime
 def test_cftimeindex_radd(index):
     date_type = index.date_type
@@ -780,7 +818,7 @@ def test_cftimeindex_radd(index):

 @requires_cftime
 @pytest.mark.parametrize("calendar", _CFTIME_CALENDARS)
-def test_timedeltaindex_add_cftimeindex(calendar):
+def test_timedeltaindex_add_cftimeindex(calendar) -> None:
     a = xr.cftime_range("2000", periods=5, calendar=calendar)
     deltas = pd.TimedeltaIndex([timedelta(days=2) for _ in range(5)])
     result = deltas + a
@@ -828,7 +866,7 @@ def test_cftimeindex_sub_timedelta_array(index, other):

 @requires_cftime
 @pytest.mark.parametrize("calendar", _CFTIME_CALENDARS)
-def test_cftimeindex_sub_cftimeindex(calendar):
+def test_cftimeindex_sub_cftimeindex(calendar) -> None:
     a = xr.cftime_range("2000", periods=5, calendar=calendar)
     b = a.shift(2, "D")
     result = b - a
@@ -867,7 +905,7 @@ def test_distant_cftime_datetime_sub_cftimeindex(calendar):

 @requires_cftime
 @pytest.mark.parametrize("calendar", _CFTIME_CALENDARS)
-def test_cftimeindex_sub_timedeltaindex(calendar):
+def test_cftimeindex_sub_timedeltaindex(calendar) -> None:
     a = xr.cftime_range("2000", periods=5, calendar=calendar)
     deltas = pd.TimedeltaIndex([timedelta(days=2) for _ in range(5)])
     result = a - deltas
@@ -903,7 +941,7 @@ def test_cftimeindex_rsub(index):

 @requires_cftime
 @pytest.mark.parametrize("freq", ["D", timedelta(days=1)])
-def test_cftimeindex_shift(index, freq):
+def test_cftimeindex_shift(index, freq) -> None:
     date_type = index.date_type
     expected_dates = [
         date_type(1, 1, 3),
@@ -918,14 +956,14 @@ def test_cftimeindex_shift(index, freq):


 @requires_cftime
-def test_cftimeindex_shift_invalid_n():
+def test_cftimeindex_shift_invalid_n() -> None:
     index = xr.cftime_range("2000", periods=3)
     with pytest.raises(TypeError):
         index.shift("a", "D")


 @requires_cftime
-def test_cftimeindex_shift_invalid_freq():
+def test_cftimeindex_shift_invalid_freq() -> None:
     index = xr.cftime_range("2000", periods=3)
     with pytest.raises(TypeError):
         index.shift(1, 1)
Obtaining file:///testbed
  Installing build dependencies: started
  Installing build dependencies: finished with status 'done'
  Checking if build backend supports build_editable: started
  Checking if build backend supports build_editable: finished with status 'done'
  Getting requirements to build editable: started
  Getting requirements to build editable: finished with status 'done'
  Preparing editable metadata (pyproject.toml): started
  Preparing editable metadata (pyproject.toml): finished with status 'done'
Requirement already satisfied: numpy>=1.18 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==0.21.2.dev12+ga31466eb.d20250211) (1.23.0)
Requirement already satisfied: pandas>=1.1 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==0.21.2.dev12+ga31466eb.d20250211) (1.5.3)
Requirement already satisfied: packaging>=20.0 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==0.21.2.dev12+ga31466eb.d20250211) (23.1)
Requirement already satisfied: python-dateutil>=2.8.1 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from pandas>=1.1->xarray==0.21.2.dev12+ga31466eb.d20250211) (2.8.2)
Requirement already satisfied: pytz>=2020.1 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from pandas>=1.1->xarray==0.21.2.dev12+ga31466eb.d20250211) (2023.3)
Requirement already satisfied: six>=1.5 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from python-dateutil>=2.8.1->pandas>=1.1->xarray==0.21.2.dev12+ga31466eb.d20250211) (1.16.0)
Building wheels for collected packages: xarray
  Building editable for xarray (pyproject.toml): started
  Building editable for xarray (pyproject.toml): finished with status 'done'
  Created wheel for xarray: filename=xarray-0.21.2.dev12+ga31466eb.d20250211-0.editable-py3-none-any.whl size=9085 sha256=4748577bd46ac9f3765d5e5ceca3c5ae3e6e95741c6b1c1605543fc0b27d9c27
  Stored in directory: /tmp/pip-ephem-wheel-cache-76jhex5s/wheels/0d/a6/cb/465a7b303d624cc531250fa27c75d038ddc29430bdb6ba7c9f
Successfully built xarray
Installing collected packages: xarray
  Attempting uninstall: xarray
    Found existing installation: xarray 0.21.2.dev12+ga31466eb
    Uninstalling xarray-0.21.2.dev12+ga31466eb:
      Successfully uninstalled xarray-0.21.2.dev12+ga31466eb
Successfully installed xarray-0.21.2.dev12+ga31466eb.d20250211
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable.It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
============================= test session starts ==============================
platform linux -- Python 3.10.14, pytest-7.4.0, pluggy-1.5.0
rootdir: /testbed
configfile: setup.cfg
plugins: env-1.1.3, cov-5.0.0, hypothesis-6.108.5, github-actions-annotate-failures-0.2.0, xdist-3.6.1
collected 15 items

xarray/tests/test_cftime_offsets.py ...............                      [100%]

=============================== warnings summary ===============================
xarray/tests/test_cftime_offsets.py::test_date_range
  /testbed/xarray/coding/cftime_offsets.py:1130: FutureWarning: Argument `closed` is deprecated in favor of `inclusive`.
    return pd.date_range(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
==================================== PASSES ====================================
=========================== short test summary info ============================
PASSED xarray/tests/test_cftime_offsets.py::test_get_date_type
PASSED xarray/tests/test_cftime_offsets.py::test_BaseCFTimeOffset_init
PASSED xarray/tests/test_cftime_offsets.py::test_BaseCFTimeOffset_eq
PASSED xarray/tests/test_cftime_offsets.py::test_Tick_next_higher_resolution
PASSED xarray/tests/test_cftime_offsets.py::test_MonthBegin_apply
PASSED xarray/tests/test_cftime_offsets.py::test_MonthEnd_apply
PASSED xarray/tests/test_cftime_offsets.py::test_QuarterBegin_apply
PASSED xarray/tests/test_cftime_offsets.py::test_QuarterEnd_apply
PASSED xarray/tests/test_cftime_offsets.py::test_YearBegin_apply
PASSED xarray/tests/test_cftime_offsets.py::test_YearEnd_apply
PASSED xarray/tests/test_cftime_offsets.py::test_to_offset
PASSED xarray/tests/test_cftime_offsets.py::test_to_cftime_datetime
PASSED xarray/tests/test_cftime_offsets.py::test_cftime_range
PASSED xarray/tests/test_cftime_offsets.py::test_date_range
PASSED xarray/tests/test_cftime_offsets.py::test_date_range_like
======================== 15 passed, 1 warning in 0.62s =========================

