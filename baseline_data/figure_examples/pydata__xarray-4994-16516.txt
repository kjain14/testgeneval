Instance ID: pydata__xarray-4994-16516

Baseline 1 (Pynguin):
Predicted Test Suite: # Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import xarray.core.accessor_dt as module_0
import numpy as module_1


def test_case_0():
    none_type_0 = None
    datetime_accessor_0 = module_0.DatetimeAccessor(none_type_0)
    assert (
        f"{type(module_0.DatetimeAccessor.weekofyear).__module__}.{type(module_0.DatetimeAccessor.weekofyear).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.DatetimeAccessor.week).__module__}.{type(module_0.DatetimeAccessor.week).__qualname__}"
        == "builtins.property"
    )


@pytest.mark.xfail(strict=True)
def test_case_1():
    str_0 = "GC?"
    var_0 = module_1.flatnonzero(str_0)
    properties_0 = module_0.Properties(var_0)
    properties_0.floor(str_0)


@pytest.mark.xfail(strict=True)
def test_case_2():
    none_type_0 = None
    datetime_accessor_0 = module_0.DatetimeAccessor(none_type_0)
    assert (
        f"{type(module_0.DatetimeAccessor.weekofyear).__module__}.{type(module_0.DatetimeAccessor.weekofyear).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.DatetimeAccessor.week).__module__}.{type(module_0.DatetimeAccessor.week).__qualname__}"
        == "builtins.property"
    )
    datetime_accessor_0.ceil(datetime_accessor_0)


@pytest.mark.xfail(strict=True)
def test_case_3():
    none_type_0 = None
    properties_0 = module_0.Properties(none_type_0)
    properties_0.round(none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_4():
    none_type_0 = None
    datetime_accessor_0 = module_0.DatetimeAccessor(none_type_0)
    assert (
        f"{type(module_0.DatetimeAccessor.weekofyear).__module__}.{type(module_0.DatetimeAccessor.weekofyear).__qualname__}"
        == "builtins.property"
    )
    assert (
        f"{type(module_0.DatetimeAccessor.week).__module__}.{type(module_0.DatetimeAccessor.week).__qualname__}"
        == "builtins.property"
    )
    datetime_accessor_0.strftime(none_type_0)

Coverage: 48.4472049689441
Mutation Score: 0.8799999999999955

Baseline 2 (CodaMosa):
Predicted Test Suite: import xarray.core.accessor_dt as module_0

def test_case_1():
    try:
        timedelta_accessor_0 = None
        combined_datetimelike_accessor_0 = None
        dict_0 = {combined_datetimelike_accessor_0: combined_datetimelike_accessor_0, combined_datetimelike_accessor_0: combined_datetimelike_accessor_0}
        properties_0 = module_0.Properties(dict_0)
        var_0 = properties_0.round(timedelta_accessor_0)
    except BaseException:
        pass


def test_case_2():
    try:
        int_0 = 4
        float_0 = -1164.737973
        properties_0 = module_0.Properties(float_0)
        var_0 = properties_0.floor(int_0)
    except BaseException:
        pass


def test_case_3():
    try:
        list_0 = None
        float_0 = -317.87
        properties_0 = module_0.Properties(float_0)
        var_0 = properties_0.ceil(list_0)
    except BaseException:
        pass


def test_case_4():
    try:
        set_0 = set()
        datetime_accessor_0 = module_0.DatetimeAccessor(set_0)
        properties_0 = module_0.Properties(datetime_accessor_0)
        bytes_0 = b'\xa3\xbd\x8f\xcb\x04\xf8@\xaf\xd1\xb1'
        timedelta_accessor_0 = module_0.TimedeltaAccessor(bytes_0)
        var_0 = datetime_accessor_0.strftime(timedelta_accessor_0)
    except BaseException:
        pass


def test_case_5():
    try:
        str_0 = 'lxz9^z'
        timedelta_accessor_0 = module_0.TimedeltaAccessor(str_0)
        bool_0 = True
        datetime_accessor_0 = module_0.DatetimeAccessor(bool_0)
        var_0 = datetime_accessor_0.isocalendar()
    except BaseException:
        pass


def test_case_6():
    try:
        complex_0 = None
        combined_datetimelike_accessor_0 = module_0.CombinedDatetimelikeAccessor(complex_0)
    except BaseException:
        pass# Automatically generated by Pynguin.


def test_case_7():
    pass


def test_case_8():
    bool_0 = False
    properties_0 = module_0.Properties(bool_0)

Coverage: 47.82608695652174
Mutation Score: 0.0

Baseline 3 (GPT-4o):
Predicted Test Suite: 
import pytest
import numpy as np
import pandas as pd
from xarray import DataArray, Dataset
from xarray.core.accessor_dt import (
    _season_from_months,
    _access_through_cftimeindex,
    _access_through_series,
    _get_date_field,
    _round_through_series_or_index,
    _round_field,
    _strftime_through_cftimeindex,
    _strftime_through_series,
    _strftime,
    Properties,
    DatetimeAccessor,
    TimedeltaAccessor,
    CombinedDatetimelikeAccessor,
)
from xarray.core.common import _contains_datetime_like_objects
from xarray.core.npcompat import DTypeLike
from xarray.core.pycompat import is_duck_dask_array

@pytest.fixture
def datetime_dataarray():
    dates = pd.date_range(start="2000/01/01", freq="D", periods=10)
    return DataArray(dates, dims=("time"))

@pytest.fixture
def timedelta_dataarray():
    deltas = pd.timedelta_range(start="1 day", freq="6H", periods=20)
    return DataArray(deltas, dims=("time"))

def test_season_from_months():
    months = np.array([1, 4, 7, 10])
    expected_seasons = np.array(["DJF", "MAM", "JJA", "SON"])
    assert np.array_equal(_season_from_months(months), expected_seasons)

def test_access_through_series(datetime_dataarray):
    result = _access_through_series(datetime_dataarray.data, "year")
    expected = np.array([2000] * 10)
    assert np.array_equal(result, expected)

def test_access_through_cftimeindex():
    # This test requires a mock or actual CFTimeIndex implementation
    pass

def test_get_date_field(datetime_dataarray):
    result = _get_date_field(datetime_dataarray.data, "month", np.int64)
    expected = np.array([1] * 10)
    assert np.array_equal(result, expected)

def test_round_through_series_or_index(datetime_dataarray):
    result = _round_through_series_or_index(datetime_dataarray.data, "floor", "D")
    expected = datetime_dataarray.data
    assert np.array_equal(result, expected)

def test_round_field(datetime_dataarray):
    result = _round_field(datetime_dataarray.data, "floor", "D")
    expected = datetime_dataarray.data
    assert np.array_equal(result, expected)

def test_strftime_through_series(datetime_dataarray):
    result = _strftime_through_series(datetime_dataarray.data, "%Y-%m-%d")
    expected = np.array([d.strftime("%Y-%m-%d") for d in datetime_dataarray.data])
    assert np.array_equal(result, expected)

def test_strftime(datetime_dataarray):
    result = _strftime(datetime_dataarray.data, "%Y-%m-%d")
    expected = np.array([d.strftime("%Y-%m-%d") for d in datetime_dataarray.data])
    assert np.array_equal(result, expected)

def test_properties_tslib_field_accessor(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    assert np.array_equal(accessor.year.data, np.array([2000] * 10))

def test_datetime_accessor_floor(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.floor("D")
    assert np.array_equal(result.data, datetime_dataarray.data)

def test_datetime_accessor_isocalendar(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.isocalendar()
    assert isinstance(result, Dataset)
    assert "year" in result
    assert "week" in result
    assert "weekday" in result

def test_timedelta_accessor_days(timedelta_dataarray):
    accessor = TimedeltaAccessor(timedelta_dataarray)
    expected_days = np.array([1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5])
    assert np.array_equal(accessor.days.data, expected_days)

def test_combined_datetimelike_accessor_datetime(datetime_dataarray):
    accessor = CombinedDatetimelikeAccessor(datetime_dataarray)
    assert isinstance(accessor, DatetimeAccessor)

def test_combined_datetimelike_accessor_timedelta(timedelta_dataarray):
    accessor = CombinedDatetimelikeAccessor(timedelta_dataarray)
    assert isinstance(accessor, TimedeltaAccessor)

def test_combined_datetimelike_accessor_invalid():
    with pytest.raises(TypeError):
        CombinedDatetimelikeAccessor(DataArray(np.array([1, 2, 3])))

Coverage: 68.94409937888199
Mutation Score: 47.37

Approach:
Predicted Test Suite: import pytest
import numpy as np
import pandas as pd
from xarray import DataArray, Dataset
from xarray.core.accessor_dt import (
    _season_from_months,
    _access_through_cftimeindex,
    _access_through_series,
    _get_date_field,
    _round_through_series_or_index,
    _round_field,
    _strftime_through_cftimeindex,
    _strftime_through_series,
    _strftime,
    Properties,
    DatetimeAccessor,
    TimedeltaAccessor,
    CombinedDatetimelikeAccessor,
)
# Additional imports for new tests
from xarray.coding.cftimeindex import CFTimeIndex

# Additional fixtures for new tests
@pytest.fixture
def cftime_dataarray():
    import cftime
    dates = CFTimeIndex([cftime.DatetimeGregorian(2000, 1, i+1) for i in range(10)])
    return DataArray(dates, dims=("time"))

# New test cases to improve coverage
def test_access_through_cftimeindex_season(cftime_dataarray):
    result = _access_through_cftimeindex(cftime_dataarray.data, "season")
    expected = np.array(["DJF"] * 10)
    assert np.array_equal(result, expected)

def test_access_through_cftimeindex_date(cftime_dataarray):
    with pytest.raises(AttributeError):
        _access_through_cftimeindex(cftime_dataarray.data, "date")

def test_access_through_series_isocalendar(datetime_dataarray):
    result = _access_through_series(datetime_dataarray.data, "isocalendar")
    assert result.shape == (3, 10)

def test_round_through_series_or_index_ceil(datetime_dataarray):
    result = _round_through_series_or_index(datetime_dataarray.data, "ceil", "D")
    expected = datetime_dataarray.data
    assert np.array_equal(result, expected)

def test_round_field_ceil(datetime_dataarray):
    result = _round_field(datetime_dataarray.data, "ceil", "D")
    expected = datetime_dataarray.data
    assert np.array_equal(result, expected)

def test_datetime_accessor_ceil(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.ceil("D")
    assert np.array_equal(result.data, datetime_dataarray.data)

def test_datetime_accessor_round(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.round("D")
    assert np.array_equal(result.data, datetime_dataarray.data)

def test_datetime_accessor_strftime(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.strftime("%Y-%m-%d")
    expected = np.array([pd.Timestamp(d).strftime("%Y-%m-%d") for d in datetime_dataarray.data])
    assert np.array_equal(result.data, expected)

def test_datetime_accessor_is_month_start(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.is_month_start
    expected = np.array([True] + [False] * 9)
    assert np.array_equal(result.data, expected)

def test_datetime_accessor_is_month_end(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.is_month_end
    expected = np.array([False] * 10)
    assert np.array_equal(result.data, expected)

def test_datetime_accessor_is_year_start(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.is_year_start
    expected = np.array([True] + [False] * 9)
    assert np.array_equal(result.data, expected)

def test_datetime_accessor_is_year_end(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.is_year_end
    expected = np.array([False] * 10)
    assert np.array_equal(result.data, expected)

def test_datetime_accessor_is_leap_year(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.is_leap_year
    expected = np.array([True] * 10)
    assert np.array_equal(result.data, expected)

from xarray.core.common import _contains_datetime_like_objects
from xarray.core.npcompat import DTypeLike
from xarray.core.pycompat import is_duck_dask_array

@pytest.fixture
def datetime_dataarray():
    dates = pd.date_range(start="2000/01/01", freq="D", periods=10)
    return DataArray(dates, dims=("time"))

@pytest.fixture
def timedelta_dataarray():
    deltas = pd.timedelta_range(start="1 day", freq="6H", periods=20)
    return DataArray(deltas, dims=("time"))

def test_season_from_months():
    months = np.array([1, 4, 7, 10])
    expected_seasons = np.array(["DJF", "MAM", "JJA", "SON"])
    assert np.array_equal(_season_from_months(months), expected_seasons)

def test_access_through_series(datetime_dataarray):
    result = _access_through_series(datetime_dataarray.data, "year")
    expected = np.array([2000] * 10)
    assert np.array_equal(result, expected)

def test_access_through_cftimeindex():
    # This test requires a mock or actual CFTimeIndex implementation
    pass

def test_get_date_field(datetime_dataarray):
    result = _get_date_field(datetime_dataarray.data, "month", np.int64)
    expected = np.array([1] * 10)
    assert np.array_equal(result, expected)

def test_round_through_series_or_index(datetime_dataarray):
    result = _round_through_series_or_index(datetime_dataarray.data, "floor", "D")
    expected = datetime_dataarray.data
    assert np.array_equal(result, expected)

def test_round_field(datetime_dataarray):
    result = _round_field(datetime_dataarray.data, "floor", "D")
    expected = datetime_dataarray.data
    assert np.array_equal(result, expected)

def test_strftime_through_series(datetime_dataarray):
    result = _strftime_through_series(datetime_dataarray.data, "%Y-%m-%d")
    expected = np.array([pd.Timestamp(d).strftime("%Y-%m-%d") for d in datetime_dataarray.data])
    assert np.array_equal(result, expected)

def test_strftime(datetime_dataarray):
    result = _strftime(datetime_dataarray.data, "%Y-%m-%d")
    expected = np.array([pd.Timestamp(d).strftime("%Y-%m-%d") for d in datetime_dataarray.data])
    assert np.array_equal(result, expected)

def test_properties_tslib_field_accessor(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    assert np.array_equal(accessor.year.data, np.array([2000] * 10))

def test_datetime_accessor_floor(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.floor("D")
    assert np.array_equal(result.data, datetime_dataarray.data)

def test_datetime_accessor_isocalendar(datetime_dataarray):
    accessor = DatetimeAccessor(datetime_dataarray)
    result = accessor.isocalendar()
    assert isinstance(result, Dataset)
    assert "year" in result
    assert "week" in result
    assert "weekday" in result

def test_timedelta_accessor_days(timedelta_dataarray):
    accessor = TimedeltaAccessor(timedelta_dataarray)
    expected_days = np.array([1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5])
    assert np.array_equal(accessor.days.data, expected_days)

def test_combined_datetimelike_accessor_datetime(datetime_dataarray):
    accessor = CombinedDatetimelikeAccessor(datetime_dataarray)
    assert isinstance(accessor, DatetimeAccessor)

def test_combined_datetimelike_accessor_timedelta(timedelta_dataarray):
    accessor = CombinedDatetimelikeAccessor(timedelta_dataarray)
    assert isinstance(accessor, TimedeltaAccessor)

def test_combined_datetimelike_accessor_invalid():
    with pytest.raises(TypeError):
        CombinedDatetimelikeAccessor(DataArray(np.array([1, 2, 3])))
Coverage: 81.36645962732919
Mutation Score: 54.39
Output: On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        xarray/tests/test_accessor_dt.py

nothing added to commit but untracked files present (use "git add" to track)
commit fc557b2468487a5c6f0553396b8b3a5c1355c58a
Author: TestGenEval <>
Date:   Wed Dec 11 12:32:10 2024 +0000

    Testing fixes

diff --git a/xarray/core/accessor_dt.py b/xarray/core/accessor_dt.py
index 561d5d30..1d4ef755 100644
--- a/xarray/core/accessor_dt.py
+++ b/xarray/core/accessor_dt.py
@@ -31,6 +31,10 @@ def _access_through_cftimeindex(values, name):
     if name == "season":
         months = values_as_cftimeindex.month
         field_values = _season_from_months(months)
+    elif name == "date":
+        raise AttributeError(
+            "'CFTimeIndex' object has no attribute `date`. Consider using the floor method instead, for instance: `.time.dt.floor('D')`."
+        )
     else:
         field_values = getattr(values_as_cftimeindex, name)
     return field_values.reshape(values.shape)
@@ -415,6 +419,10 @@ class DatetimeAccessor(Properties):
         "time", "Timestamps corresponding to datetimes", object
     )

+    date = Properties._tslib_field_accessor(
+        "date", "Date corresponding to datetimes", object
+    )
+
     is_month_start = Properties._tslib_field_accessor(
         "is_month_start",
         "Indicates whether the date is the first day of the month.",
diff --git a/xarray/tests/test_accessor_dt.py b/xarray/tests/test_accessor_dt.py
deleted file mode 100644
index 984bfc76..00000000
--- a/xarray/tests/test_accessor_dt.py
+++ /dev/null
@@ -1,626 +0,0 @@
-from distutils.version import LooseVersion
-
-import numpy as np
-import pandas as pd
-import pytest
-
-import xarray as xr
-
-from . import (
-    assert_array_equal,
-    assert_chunks_equal,
-    assert_equal,
-    assert_identical,
-    raise_if_dask_computes,
-    raises_regex,
-    requires_cftime,
-    requires_dask,
-)
-
-
-class TestDatetimeAccessor:
-    @pytest.fixture(autouse=True)
-    def setup(self):
-        nt = 100
-        data = np.random.rand(10, 10, nt)
-        lons = np.linspace(0, 11, 10)
-        lats = np.linspace(0, 20, 10)
-        self.times = pd.date_range(start="2000/01/01", freq="H", periods=nt)
-
-        self.data = xr.DataArray(
-            data,
-            coords=[lons, lats, self.times],
-            dims=["lon", "lat", "time"],
-            name="data",
-        )
-
-        self.times_arr = np.random.choice(self.times, size=(10, 10, nt))
-        self.times_data = xr.DataArray(
-            self.times_arr,
-            coords=[lons, lats, self.times],
-            dims=["lon", "lat", "time"],
-            name="data",
-        )
-
-    @pytest.mark.parametrize(
-        "field",
-        [
-            "year",
-            "month",
-            "day",
-            "hour",
-            "minute",
-            "second",
-            "microsecond",
-            "nanosecond",
-            "week",
-            "weekofyear",
-            "dayofweek",
-            "weekday",
-            "dayofyear",
-            "quarter",
-            "is_month_start",
-            "is_month_end",
-            "is_quarter_start",
-            "is_quarter_end",
-            "is_year_start",
-            "is_year_end",
-            "is_leap_year",
-        ],
-    )
-    def test_field_access(self, field):
-
-        if LooseVersion(pd.__version__) >= "1.1.0" and field in ["week", "weekofyear"]:
-            data = self.times.isocalendar()["week"]
-        else:
-            data = getattr(self.times, field)
-
-        expected = xr.DataArray(data, name=field, coords=[self.times], dims=["time"])
-
-        if field in ["week", "weekofyear"]:
-            with pytest.warns(
-                FutureWarning, match="dt.weekofyear and dt.week have been deprecated"
-            ):
-                actual = getattr(self.data.time.dt, field)
-        else:
-            actual = getattr(self.data.time.dt, field)
-
-        assert_equal(expected, actual)
-
-    @pytest.mark.parametrize(
-        "field, pandas_field",
-        [
-            ("year", "year"),
-            ("week", "week"),
-            ("weekday", "day"),
-        ],
-    )
-    def test_isocalendar(self, field, pandas_field):
-
-        if LooseVersion(pd.__version__) < "1.1.0":
-            with raises_regex(
-                AttributeError, "'isocalendar' not available in pandas < 1.1.0"
-            ):
-                self.data.time.dt.isocalendar()[field]
-            return
-
-        # pandas isocalendar has dtypy UInt32Dtype, convert to Int64
-        expected = pd.Int64Index(getattr(self.times.isocalendar(), pandas_field))
-        expected = xr.DataArray(
-            expected, name=field, coords=[self.times], dims=["time"]
-        )
-
-        actual = self.data.time.dt.isocalendar()[field]
-        assert_equal(expected, actual)
-
-    def test_strftime(self):
-        assert (
-            "2000-01-01 01:00:00" == self.data.time.dt.strftime("%Y-%m-%d %H:%M:%S")[1]
-        )
-
-    def test_not_datetime_type(self):
-        nontime_data = self.data.copy()
-        int_data = np.arange(len(self.data.time)).astype("int8")
-        nontime_data = nontime_data.assign_coords(time=int_data)
-        with raises_regex(TypeError, "dt"):
-            nontime_data.time.dt
-
-    @pytest.mark.filterwarnings("ignore:dt.weekofyear and dt.week have been deprecated")
-    @requires_dask
-    @pytest.mark.parametrize(
-        "field",
-        [
-            "year",
-            "month",
-            "day",
-            "hour",
-            "minute",
-            "second",
-            "microsecond",
-            "nanosecond",
-            "week",
-            "weekofyear",
-            "dayofweek",
-            "weekday",
-            "dayofyear",
-            "quarter",
-            "is_month_start",
-            "is_month_end",
-            "is_quarter_start",
-            "is_quarter_end",
-            "is_year_start",
-            "is_year_end",
-            "is_leap_year",
-        ],
-    )
-    def test_dask_field_access(self, field):
-        import dask.array as da
-
-        expected = getattr(self.times_data.dt, field)
-
-        dask_times_arr = da.from_array(self.times_arr, chunks=(5, 5, 50))
-        dask_times_2d = xr.DataArray(
-            dask_times_arr, coords=self.data.coords, dims=self.data.dims, name="data"
-        )
-
-        with raise_if_dask_computes():
-            actual = getattr(dask_times_2d.dt, field)
-
-        assert isinstance(actual.data, da.Array)
-        assert_chunks_equal(actual, dask_times_2d)
-        assert_equal(actual.compute(), expected.compute())
-
-    @requires_dask
-    @pytest.mark.parametrize(
-        "field",
-        [
-            "year",
-            "week",
-            "weekday",
-        ],
-    )
-    def test_isocalendar_dask(self, field):
-        import dask.array as da
-
-        if LooseVersion(pd.__version__) < "1.1.0":
-            with raises_regex(
-                AttributeError, "'isocalendar' not available in pandas < 1.1.0"
-            ):
-                self.data.time.dt.isocalendar()[field]
-            return
-
-        expected = getattr(self.times_data.dt.isocalendar(), field)
-
-        dask_times_arr = da.from_array(self.times_arr, chunks=(5, 5, 50))
-        dask_times_2d = xr.DataArray(
-            dask_times_arr, coords=self.data.coords, dims=self.data.dims, name="data"
-        )
-
-        with raise_if_dask_computes():
-            actual = dask_times_2d.dt.isocalendar()[field]
-
-        assert isinstance(actual.data, da.Array)
-        assert_chunks_equal(actual, dask_times_2d)
-        assert_equal(actual.compute(), expected.compute())
-
-    @requires_dask
-    @pytest.mark.parametrize(
-        "method, parameters",
-        [
-            ("floor", "D"),
-            ("ceil", "D"),
-            ("round", "D"),
-            ("strftime", "%Y-%m-%d %H:%M:%S"),
-        ],
-    )
-    def test_dask_accessor_method(self, method, parameters):
-        import dask.array as da
-
-        expected = getattr(self.times_data.dt, method)(parameters)
-        dask_times_arr = da.from_array(self.times_arr, chunks=(5, 5, 50))
-        dask_times_2d = xr.DataArray(
-            dask_times_arr, coords=self.data.coords, dims=self.data.dims, name="data"
-        )
-
-        with raise_if_dask_computes():
-            actual = getattr(dask_times_2d.dt, method)(parameters)
-
-        assert isinstance(actual.data, da.Array)
-        assert_chunks_equal(actual, dask_times_2d)
-        assert_equal(actual.compute(), expected.compute())
-
-    def test_seasons(self):
-        dates = pd.date_range(start="2000/01/01", freq="M", periods=12)
-        dates = xr.DataArray(dates)
-        seasons = [
-            "DJF",
-            "DJF",
-            "MAM",
-            "MAM",
-            "MAM",
-            "JJA",
-            "JJA",
-            "JJA",
-            "SON",
-            "SON",
-            "SON",
-            "DJF",
-        ]
-        seasons = xr.DataArray(seasons)
-
-        assert_array_equal(seasons.values, dates.dt.season.values)
-
-    @pytest.mark.parametrize(
-        "method, parameters", [("floor", "D"), ("ceil", "D"), ("round", "D")]
-    )
-    def test_accessor_method(self, method, parameters):
-        dates = pd.date_range("2014-01-01", "2014-05-01", freq="H")
-        xdates = xr.DataArray(dates, dims=["time"])
-        expected = getattr(dates, method)(parameters)
-        actual = getattr(xdates.dt, method)(parameters)
-        assert_array_equal(expected, actual)
-
-
-class TestTimedeltaAccessor:
-    @pytest.fixture(autouse=True)
-    def setup(self):
-        nt = 100
-        data = np.random.rand(10, 10, nt)
-        lons = np.linspace(0, 11, 10)
-        lats = np.linspace(0, 20, 10)
-        self.times = pd.timedelta_range(start="1 day", freq="6H", periods=nt)
-
-        self.data = xr.DataArray(
-            data,
-            coords=[lons, lats, self.times],
-            dims=["lon", "lat", "time"],
-            name="data",
-        )
-
-        self.times_arr = np.random.choice(self.times, size=(10, 10, nt))
-        self.times_data = xr.DataArray(
-            self.times_arr,
-            coords=[lons, lats, self.times],
-            dims=["lon", "lat", "time"],
-            name="data",
-        )
-
-    def test_not_datetime_type(self):
-        nontime_data = self.data.copy()
-        int_data = np.arange(len(self.data.time)).astype("int8")
-        nontime_data = nontime_data.assign_coords(time=int_data)
-        with raises_regex(TypeError, "dt"):
-            nontime_data.time.dt
-
-    @pytest.mark.parametrize(
-        "field", ["days", "seconds", "microseconds", "nanoseconds"]
-    )
-    def test_field_access(self, field):
-        expected = xr.DataArray(
-            getattr(self.times, field), name=field, coords=[self.times], dims=["time"]
-        )
-        actual = getattr(self.data.time.dt, field)
-        assert_equal(expected, actual)
-
-    @pytest.mark.parametrize(
-        "method, parameters", [("floor", "D"), ("ceil", "D"), ("round", "D")]
-    )
-    def test_accessor_methods(self, method, parameters):
-        dates = pd.timedelta_range(start="1 day", end="30 days", freq="6H")
-        xdates = xr.DataArray(dates, dims=["time"])
-        expected = getattr(dates, method)(parameters)
-        actual = getattr(xdates.dt, method)(parameters)
-        assert_array_equal(expected, actual)
-
-    @requires_dask
-    @pytest.mark.parametrize(
-        "field", ["days", "seconds", "microseconds", "nanoseconds"]
-    )
-    def test_dask_field_access(self, field):
-        import dask.array as da
-
-        expected = getattr(self.times_data.dt, field)
-
-        dask_times_arr = da.from_array(self.times_arr, chunks=(5, 5, 50))
-        dask_times_2d = xr.DataArray(
-            dask_times_arr, coords=self.data.coords, dims=self.data.dims, name="data"
-        )
-
-        with raise_if_dask_computes():
-            actual = getattr(dask_times_2d.dt, field)
-
-        assert isinstance(actual.data, da.Array)
-        assert_chunks_equal(actual, dask_times_2d)
-        assert_equal(actual, expected)
-
-    @requires_dask
-    @pytest.mark.parametrize(
-        "method, parameters", [("floor", "D"), ("ceil", "D"), ("round", "D")]
-    )
-    def test_dask_accessor_method(self, method, parameters):
-        import dask.array as da
-
-        expected = getattr(self.times_data.dt, method)(parameters)
-        dask_times_arr = da.from_array(self.times_arr, chunks=(5, 5, 50))
-        dask_times_2d = xr.DataArray(
-            dask_times_arr, coords=self.data.coords, dims=self.data.dims, name="data"
-        )
-
-        with raise_if_dask_computes():
-            actual = getattr(dask_times_2d.dt, method)(parameters)
-
-        assert isinstance(actual.data, da.Array)
-        assert_chunks_equal(actual, dask_times_2d)
-        assert_equal(actual.compute(), expected.compute())
-
-
-_CFTIME_CALENDARS = [
-    "365_day",
-    "360_day",
-    "julian",
-    "all_leap",
-    "366_day",
-    "gregorian",
-    "proleptic_gregorian",
-]
-_NT = 100
-
-
-@pytest.fixture(params=_CFTIME_CALENDARS)
-def calendar(request):
-    return request.param
-
-
-@pytest.fixture()
-def times(calendar):
-    import cftime
-
-    return cftime.num2date(
-        np.arange(_NT),
-        units="hours since 2000-01-01",
-        calendar=calendar,
-        only_use_cftime_datetimes=True,
-    )
-
-
-@pytest.fixture()
-def data(times):
-    data = np.random.rand(10, 10, _NT)
-    lons = np.linspace(0, 11, 10)
-    lats = np.linspace(0, 20, 10)
-    return xr.DataArray(
-        data, coords=[lons, lats, times], dims=["lon", "lat", "time"], name="data"
-    )
-
-
-@pytest.fixture()
-def times_3d(times):
-    lons = np.linspace(0, 11, 10)
-    lats = np.linspace(0, 20, 10)
-    times_arr = np.random.choice(times, size=(10, 10, _NT))
-    return xr.DataArray(
-        times_arr, coords=[lons, lats, times], dims=["lon", "lat", "time"], name="data"
-    )
-
-
-@requires_cftime
-@pytest.mark.parametrize(
-    "field", ["year", "month", "day", "hour", "dayofyear", "dayofweek"]
-)
-def test_field_access(data, field):
-    if field == "dayofyear" or field == "dayofweek":
-        pytest.importorskip("cftime", minversion="1.0.2.1")
-    result = getattr(data.time.dt, field)
-    expected = xr.DataArray(
-        getattr(xr.coding.cftimeindex.CFTimeIndex(data.time.values), field),
-        name=field,
-        coords=data.time.coords,
-        dims=data.time.dims,
-    )
-
-    assert_equal(result, expected)
-
-
-@requires_cftime
-def test_isocalendar_cftime(data):
-
-    with raises_regex(
-        AttributeError, "'CFTimeIndex' object has no attribute 'isocalendar'"
-    ):
-        data.time.dt.isocalendar()
-
-
-@requires_cftime
-@pytest.mark.filterwarnings("ignore::RuntimeWarning")
-def test_cftime_strftime_access(data):
-    """ compare cftime formatting against datetime formatting """
-    date_format = "%Y%m%d%H"
-    result = data.time.dt.strftime(date_format)
-    datetime_array = xr.DataArray(
-        xr.coding.cftimeindex.CFTimeIndex(data.time.values).to_datetimeindex(),
-        name="stftime",
-        coords=data.time.coords,
-        dims=data.time.dims,
-    )
-    expected = datetime_array.dt.strftime(date_format)
-    assert_equal(result, expected)
-
-
-@requires_cftime
-@requires_dask
-@pytest.mark.parametrize(
-    "field", ["year", "month", "day", "hour", "dayofyear", "dayofweek"]
-)
-def test_dask_field_access_1d(data, field):
-    import dask.array as da
-
-    if field == "dayofyear" or field == "dayofweek":
-        pytest.importorskip("cftime", minversion="1.0.2.1")
-    expected = xr.DataArray(
-        getattr(xr.coding.cftimeindex.CFTimeIndex(data.time.values), field),
-        name=field,
-        dims=["time"],
-    )
-    times = xr.DataArray(data.time.values, dims=["time"]).chunk({"time": 50})
-    result = getattr(times.dt, field)
-    assert isinstance(result.data, da.Array)
-    assert result.chunks == times.chunks
-    assert_equal(result.compute(), expected)
-
-
-@requires_cftime
-@requires_dask
-@pytest.mark.parametrize(
-    "field", ["year", "month", "day", "hour", "dayofyear", "dayofweek"]
-)
-def test_dask_field_access(times_3d, data, field):
-    import dask.array as da
-
-    if field == "dayofyear" or field == "dayofweek":
-        pytest.importorskip("cftime", minversion="1.0.2.1")
-    expected = xr.DataArray(
-        getattr(
-            xr.coding.cftimeindex.CFTimeIndex(times_3d.values.ravel()), field
-        ).reshape(times_3d.shape),
-        name=field,
-        coords=times_3d.coords,
-        dims=times_3d.dims,
-    )
-    times_3d = times_3d.chunk({"lon": 5, "lat": 5, "time": 50})
-    result = getattr(times_3d.dt, field)
-    assert isinstance(result.data, da.Array)
-    assert result.chunks == times_3d.chunks
-    assert_equal(result.compute(), expected)
-
-
-@pytest.fixture()
-def cftime_date_type(calendar):
-    from .test_coding_times import _all_cftime_date_types
-
-    return _all_cftime_date_types()[calendar]
-
-
-@requires_cftime
-def test_seasons(cftime_date_type):
-    dates = np.array([cftime_date_type(2000, month, 15) for month in range(1, 13)])
-    dates = xr.DataArray(dates)
-    seasons = [
-        "DJF",
-        "DJF",
-        "MAM",
-        "MAM",
-        "MAM",
-        "JJA",
-        "JJA",
-        "JJA",
-        "SON",
-        "SON",
-        "SON",
-        "DJF",
-    ]
-    seasons = xr.DataArray(seasons)
-
-    assert_array_equal(seasons.values, dates.dt.season.values)
-
-
-@pytest.fixture
-def cftime_rounding_dataarray(cftime_date_type):
-    return xr.DataArray(
-        [
-            [cftime_date_type(1, 1, 1, 1), cftime_date_type(1, 1, 1, 15)],
-            [cftime_date_type(1, 1, 1, 23), cftime_date_type(1, 1, 2, 1)],
-        ]
-    )
-
-
-@requires_cftime
-@requires_dask
-@pytest.mark.parametrize("use_dask", [False, True])
-def test_cftime_floor_accessor(cftime_rounding_dataarray, cftime_date_type, use_dask):
-    import dask.array as da
-
-    freq = "D"
-    expected = xr.DataArray(
-        [
-            [cftime_date_type(1, 1, 1, 0), cftime_date_type(1, 1, 1, 0)],
-            [cftime_date_type(1, 1, 1, 0), cftime_date_type(1, 1, 2, 0)],
-        ],
-        name="floor",
-    )
-
-    if use_dask:
-        chunks = {"dim_0": 1}
-        # Currently a compute is done to inspect a single value of the array
-        # if it is of object dtype to check if it is a cftime.datetime (if not
-        # we raise an error when using the dt accessor).
-        with raise_if_dask_computes(max_computes=1):
-            result = cftime_rounding_dataarray.chunk(chunks).dt.floor(freq)
-        expected = expected.chunk(chunks)
-        assert isinstance(result.data, da.Array)
-        assert result.chunks == expected.chunks
-    else:
-        result = cftime_rounding_dataarray.dt.floor(freq)
-
-    assert_identical(result, expected)
-
-
-@requires_cftime
-@requires_dask
-@pytest.mark.parametrize("use_dask", [False, True])
-def test_cftime_ceil_accessor(cftime_rounding_dataarray, cftime_date_type, use_dask):
-    import dask.array as da
-
-    freq = "D"
-    expected = xr.DataArray(
-        [
-            [cftime_date_type(1, 1, 2, 0), cftime_date_type(1, 1, 2, 0)],
-            [cftime_date_type(1, 1, 2, 0), cftime_date_type(1, 1, 3, 0)],
-        ],
-        name="ceil",
-    )
-
-    if use_dask:
-        chunks = {"dim_0": 1}
-        # Currently a compute is done to inspect a single value of the array
-        # if it is of object dtype to check if it is a cftime.datetime (if not
-        # we raise an error when using the dt accessor).
-        with raise_if_dask_computes(max_computes=1):
-            result = cftime_rounding_dataarray.chunk(chunks).dt.ceil(freq)
-        expected = expected.chunk(chunks)
-        assert isinstance(result.data, da.Array)
-        assert result.chunks == expected.chunks
-    else:
-        result = cftime_rounding_dataarray.dt.ceil(freq)
-
-    assert_identical(result, expected)
-
-
-@requires_cftime
-@requires_dask
-@pytest.mark.parametrize("use_dask", [False, True])
-def test_cftime_round_accessor(cftime_rounding_dataarray, cftime_date_type, use_dask):
-    import dask.array as da
-
-    freq = "D"
-    expected = xr.DataArray(
-        [
-            [cftime_date_type(1, 1, 1, 0), cftime_date_type(1, 1, 2, 0)],
-            [cftime_date_type(1, 1, 2, 0), cftime_date_type(1, 1, 2, 0)],
-        ],
-        name="round",
-    )
-
-    if use_dask:
-        chunks = {"dim_0": 1}
-        # Currently a compute is done to inspect a single value of the array
-        # if it is of object dtype to check if it is a cftime.datetime (if not
-        # we raise an error when using the dt accessor).
-        with raise_if_dask_computes(max_computes=1):
-            result = cftime_rounding_dataarray.chunk(chunks).dt.round(freq)
-        expected = expected.chunk(chunks)
-        assert isinstance(result.data, da.Array)
-        assert result.chunks == expected.chunks
-    else:
-        result = cftime_rounding_dataarray.dt.round(freq)
-
-    assert_identical(result, expected)
Obtaining file:///testbed
  Installing build dependencies: started
  Installing build dependencies: finished with status 'done'
  Checking if build backend supports build_editable: started
  Checking if build backend supports build_editable: finished with status 'done'
  Getting requirements to build editable: started
  Getting requirements to build editable: finished with status 'done'
  Preparing editable metadata (pyproject.toml): started
  Preparing editable metadata (pyproject.toml): finished with status 'done'
Requirement already satisfied: numpy>=1.15 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==0.17.1.dev20+gfc557b24) (1.23.0)
Requirement already satisfied: pandas>=0.25 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==0.17.1.dev20+gfc557b24) (1.5.3)
Requirement already satisfied: setuptools>=40.4 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==0.17.1.dev20+gfc557b24) (68.0.0)
Requirement already satisfied: python-dateutil>=2.8.1 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from pandas>=0.25->xarray==0.17.1.dev20+gfc557b24) (2.8.2)
Requirement already satisfied: pytz>=2020.1 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from pandas>=0.25->xarray==0.17.1.dev20+gfc557b24) (2023.3)
Requirement already satisfied: six>=1.5 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from python-dateutil>=2.8.1->pandas>=0.25->xarray==0.17.1.dev20+gfc557b24) (1.16.0)
Building wheels for collected packages: xarray
  Building editable for xarray (pyproject.toml): started
  Building editable for xarray (pyproject.toml): finished with status 'done'
  Created wheel for xarray: filename=xarray-0.17.1.dev20+gfc557b24-0.editable-py3-none-any.whl size=8897 sha256=e0d8296a39f091672dfa45f14fefc9c2d2efbd27c7c1500514017eb41a1d5f88
  Stored in directory: /tmp/pip-ephem-wheel-cache-wvxfn922/wheels/0d/a6/cb/465a7b303d624cc531250fa27c75d038ddc29430bdb6ba7c9f
Successfully built xarray
Installing collected packages: xarray
  Attempting uninstall: xarray
    Found existing installation: xarray 0.17.1.dev19+gc7c4aae1
    Uninstalling xarray-0.17.1.dev19+gc7c4aae1:
      Successfully uninstalled xarray-0.17.1.dev19+gc7c4aae1
Successfully installed xarray-0.17.1.dev20+gfc557b24
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable.It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
============================= test session starts ==============================
platform linux -- Python 3.10.14, pytest-7.4.0, pluggy-1.5.0
rootdir: /testbed
configfile: setup.cfg
plugins: env-1.1.3, cov-5.0.0, hypothesis-6.108.5, xdist-3.6.1
collected 28 items

xarray/tests/test_accessor_dt.py ............................            [100%]

=============================== warnings summary ===============================
xarray/__init__.py:1
  /testbed/xarray/__init__.py:1: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html
    import pkg_resources

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap.responses')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2350
../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2350
../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2350
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2350: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(parent)

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap.handlers')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap.tests')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

xarray/core/dask_array_compat.py:61
xarray/core/dask_array_compat.py:61
  /testbed/xarray/core/dask_array_compat.py:61: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(dask_version) > LooseVersion("2.9.0"):

xarray/core/pdcompat.py:45
  /testbed/xarray/core/pdcompat.py:45: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(pd.__version__) < "0.25.0":

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/setuptools/_distutils/version.py:345
xarray/tests/test_accessor_dt.py::test_datetime_accessor_isocalendar
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/setuptools/_distutils/version.py:345: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    other = LooseVersion(other)

xarray/coding/cftimeindex.py:62
xarray/coding/cftimeindex.py:62
  /testbed/xarray/coding/cftimeindex.py:62: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(pd.__version__) > LooseVersion("1.2.3"):

xarray/tests/__init__.py:59
xarray/tests/__init__.py:59
xarray/tests/__init__.py:59
xarray/tests/__init__.py:59
xarray/tests/__init__.py:59
xarray/tests/__init__.py:59
  /testbed/xarray/tests/__init__.py:59: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    return version.LooseVersion(vstring)

xarray/tests/test_accessor_dt.py::test_access_through_cftimeindex_season
xarray/tests/test_accessor_dt.py::test_access_through_cftimeindex_season
  /testbed/xarray/coding/cftimeindex.py:194: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(version) >= LooseVersion(min_cftime_version):

xarray/tests/test_accessor_dt.py::test_datetime_accessor_isocalendar
  /testbed/xarray/core/accessor_dt.py:341: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(pd.__version__) < "1.1.0":

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
==================================== PASSES ====================================
=========================== short test summary info ============================
PASSED xarray/tests/test_accessor_dt.py::test_access_through_cftimeindex_season
PASSED xarray/tests/test_accessor_dt.py::test_access_through_cftimeindex_date
PASSED xarray/tests/test_accessor_dt.py::test_access_through_series_isocalendar
PASSED xarray/tests/test_accessor_dt.py::test_round_through_series_or_index_ceil
PASSED xarray/tests/test_accessor_dt.py::test_round_field_ceil
PASSED xarray/tests/test_accessor_dt.py::test_datetime_accessor_ceil
PASSED xarray/tests/test_accessor_dt.py::test_datetime_accessor_round
PASSED xarray/tests/test_accessor_dt.py::test_datetime_accessor_strftime
PASSED xarray/tests/test_accessor_dt.py::test_datetime_accessor_is_month_start
PASSED xarray/tests/test_accessor_dt.py::test_datetime_accessor_is_month_end
PASSED xarray/tests/test_accessor_dt.py::test_datetime_accessor_is_year_start
PASSED xarray/tests/test_accessor_dt.py::test_datetime_accessor_is_year_end
PASSED xarray/tests/test_accessor_dt.py::test_datetime_accessor_is_leap_year
PASSED xarray/tests/test_accessor_dt.py::test_season_from_months
PASSED xarray/tests/test_accessor_dt.py::test_access_through_series
PASSED xarray/tests/test_accessor_dt.py::test_access_through_cftimeindex
PASSED xarray/tests/test_accessor_dt.py::test_get_date_field
PASSED xarray/tests/test_accessor_dt.py::test_round_through_series_or_index
PASSED xarray/tests/test_accessor_dt.py::test_round_field
PASSED xarray/tests/test_accessor_dt.py::test_strftime_through_series
PASSED xarray/tests/test_accessor_dt.py::test_strftime
PASSED xarray/tests/test_accessor_dt.py::test_properties_tslib_field_accessor
PASSED xarray/tests/test_accessor_dt.py::test_datetime_accessor_floor
PASSED xarray/tests/test_accessor_dt.py::test_datetime_accessor_isocalendar
PASSED xarray/tests/test_accessor_dt.py::test_timedelta_accessor_days
PASSED xarray/tests/test_accessor_dt.py::test_combined_datetimelike_accessor_datetime
PASSED xarray/tests/test_accessor_dt.py::test_combined_datetimelike_accessor_timedelta
PASSED xarray/tests/test_accessor_dt.py::test_combined_datetimelike_accessor_invalid
======================= 28 passed, 24 warnings in 5.31s ========================

