Instance ID: pydata__xarray-7393-16581

Baseline 1 (Pynguin):
Predicted Test Suite: # Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import xarray.core.indexing as module_0
import pandas._version as module_1
import platform as module_2
import numpy.ma.extras as module_3
import numpy.compat.py3k as module_4
import encodings.cp437 as module_5
import numexpr.utils as module_6
import numpy as module_7


def test_case_0():
    explicitly_indexed_0 = module_0.ExplicitlyIndexed()


@pytest.mark.xfail(strict=True)
def test_case_1():
    str_0 = ":jmjP97@ "
    module_0.expanded_indexer(str_0, str_0)


def test_case_2():
    none_type_0 = None
    with pytest.raises(TypeError):
        module_0.ExplicitIndexer(none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_3():
    none_type_0 = None
    var_0 = module_0.as_integer_or_none(none_type_0)
    module_0.slice_slice(none_type_0, none_type_0, none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_4():
    indexing_support_0 = module_0.IndexingSupport.VECTORIZED
    module_0.as_integer_or_none(indexing_support_0)


def test_case_5():
    var_0 = module_1.get_versions()
    with pytest.raises(TypeError):
        module_0.VectorizedIndexer(var_0)


@pytest.mark.xfail(strict=True)
def test_case_6():
    var_0 = module_2.python_version_tuple()
    module_0.LazilyIndexedArray(var_0)


@pytest.mark.xfail(strict=True)
def test_case_7():
    var_0 = module_3.mr_class()
    module_0.LazilyIndexedArray(var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_8():
    var_0 = module_2.python_build()
    module_0.LazilyVectorizedIndexedArray(var_0, var_0)


def test_case_9():
    var_0 = module_2.python_version_tuple()
    with pytest.raises(TypeError):
        module_0.create_mask(var_0, var_0, var_0)


def test_case_10():
    var_0 = module_2.python_version_tuple()
    bool_0 = module_0.is_fancy_indexer(var_0)
    assert bool_0 is True


@pytest.mark.xfail(strict=True)
def test_case_11():
    none_type_0 = None
    module_0.slice_slice(none_type_0, none_type_0, none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_12():
    var_0 = module_2.python_version_tuple()
    module_0.PandasMultiIndexingAdapter(var_0)


@pytest.mark.xfail(strict=True)
def test_case_13():
    var_0 = module_2.python_version_tuple()
    module_0.ImplicitToExplicitIndexingAdapter(var_0)


@pytest.mark.xfail(strict=True)
def test_case_14():
    none_type_0 = None
    dask_indexing_adapter_0 = module_0.DaskIndexingAdapter(none_type_0)
    assert (
        f"{type(dask_indexing_adapter_0).__module__}.{type(dask_indexing_adapter_0).__qualname__}"
        == "xarray.core.indexing.DaskIndexingAdapter"
    )
    assert (
        f"{type(module_0.DaskIndexingAdapter.array).__module__}.{type(module_0.DaskIndexingAdapter.array).__qualname__}"
        == "builtins.member_descriptor"
    )
    dask_indexing_adapter_0.__array__(none_type_0)


def test_case_15():
    str_0 = "MEmtCU3XbO"
    with pytest.raises(TypeError):
        module_0.OuterIndexer(str_0)


@pytest.mark.xfail(strict=True)
def test_case_16():
    none_type_0 = None
    module_0.as_integer_slice(none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_17():
    var_0 = module_2.python_version_tuple()
    module_0.explicit_indexing_adapter(var_0, var_0, var_0, var_0)


def test_case_18():
    none_type_0 = None
    var_0 = module_4.asbytes_nested(none_type_0)
    with pytest.raises(TypeError):
        module_0.BasicIndexer(var_0)


@pytest.mark.xfail(strict=True)
def test_case_19():
    indexing_support_0 = module_0.IndexingSupport.OUTER_1VECTOR
    module_0.CopyOnWriteArray(indexing_support_0)


@pytest.mark.xfail(strict=True)
def test_case_20():
    var_0 = module_2.python_version_tuple()
    bool_0 = module_0.is_fancy_indexer(var_0)
    assert bool_0 is True
    bool_1 = module_0.is_fancy_indexer(bool_0)
    assert bool_1 is False
    module_0.LazilyIndexedArray(bool_0, bool_1)


def test_case_21():
    var_0 = module_2.python_version_tuple()
    with pytest.raises(TypeError):
        module_0.ArrayApiIndexingAdapter(var_0)


def test_case_22():
    int_0 = -1158
    tuple_0 = (int_0, int_0)
    outer_indexer_0 = module_0.OuterIndexer(tuple_0)
    assert (
        f"{type(outer_indexer_0).__module__}.{type(outer_indexer_0).__qualname__}"
        == "xarray.core.indexing.OuterIndexer"
    )


def test_case_23():
    var_0 = module_2.python_version_tuple()
    with pytest.raises(TypeError):
        module_0.OuterIndexer(var_0)


def test_case_24():
    var_0 = module_5.getregentry()
    with pytest.raises(TypeError):
        module_0.NdArrayLikeIndexingAdapter(var_0)


@pytest.mark.xfail(strict=True)
def test_case_25():
    none_type_0 = None
    module_0.posify_mask_indexer(none_type_0)


def test_case_26():
    var_0 = module_2.python_version_tuple()
    with pytest.raises(TypeError):
        module_0.NumpyIndexingAdapter(var_0)


def test_case_27():
    var_0 = module_2.python_version_tuple()
    with pytest.raises(TypeError):
        module_0.VectorizedIndexer(var_0)


def test_case_28():
    bool_0 = False
    with pytest.raises(IndexError):
        module_0.expanded_indexer(bool_0, bool_0)


@pytest.mark.xfail(strict=True)
def test_case_29():
    var_0 = module_5.getregentry()
    module_0.expanded_indexer(var_0, var_0)


@pytest.mark.xfail(strict=True)
def test_case_30():
    bool_0 = False
    tuple_0 = (bool_0, bool_0)
    module_0.merge_sel_results(tuple_0)


def test_case_31():
    var_0 = module_2.python_version_tuple()
    with pytest.raises(TypeError):
        module_0.BasicIndexer(var_0)


def test_case_32():
    str_0 = ":jmjP97@ "
    bool_0 = module_0.is_fancy_indexer(str_0)
    assert bool_0 is True
    none_type_0 = None
    var_0 = module_0.expanded_indexer(bool_0, bool_0)
    var_1 = var_0.__eq__(var_0)
    with pytest.raises(TypeError):
        module_0.OuterIndexer(none_type_0)


def test_case_33():
    explicitly_indexed_0 = module_0.ExplicitlyIndexed()
    var_0 = module_0.as_indexable(explicitly_indexed_0)
    assert (
        f"{type(var_0).__module__}.{type(var_0).__qualname__}"
        == "xarray.core.indexing.ExplicitlyIndexed"
    )
    with pytest.raises(TypeError):
        module_0.OuterIndexer(var_0)


@pytest.mark.xfail(strict=True)
def test_case_34():
    explicitly_indexed_0 = module_0.ExplicitlyIndexed()
    copy_on_write_array_0 = module_0.CopyOnWriteArray(explicitly_indexed_0)
    assert (
        f"{type(copy_on_write_array_0).__module__}.{type(copy_on_write_array_0).__qualname__}"
        == "xarray.core.indexing.CopyOnWriteArray"
    )
    assert (
        f"{type(module_0.CopyOnWriteArray.array).__module__}.{type(module_0.CopyOnWriteArray.array).__qualname__}"
        == "builtins.member_descriptor"
    )
    var_0 = module_6.get_num_threads()
    module_7.convolve(explicitly_indexed_0, copy_on_write_array_0, explicitly_indexed_0)


def test_case_35():
    dict_0 = {}
    var_0 = module_0.group_indexers_by_index(dict_0, dict_0, dict_0)


def test_case_36():
    var_0 = module_7.__dir__()
    bool_0 = module_0.is_fancy_indexer(var_0)
    assert bool_0 is True


@pytest.mark.xfail(strict=True)
def test_case_37():
    var_0 = module_2.python_version_tuple()
    list_0 = []
    int_0 = list_0.__len__()
    bool_0 = module_0.is_fancy_indexer(list_0)
    assert bool_0 is False
    none_type_0 = None
    module_0.expanded_indexer(list_0, none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_38():
    bool_0 = False
    none_type_0 = None
    dask_indexing_adapter_0 = module_0.DaskIndexingAdapter(bool_0)
    assert (
        f"{type(dask_indexing_adapter_0).__module__}.{type(dask_indexing_adapter_0).__qualname__}"
        == "xarray.core.indexing.DaskIndexingAdapter"
    )
    assert (
        f"{type(module_0.DaskIndexingAdapter.array).__module__}.{type(module_0.DaskIndexingAdapter.array).__qualname__}"
        == "builtins.member_descriptor"
    )
    dask_indexing_adapter_0.transpose(none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_39():
    none_type_0 = None
    module_0.MemoryCachedArray(none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_40():
    str_0 = ":jmjP97@ "
    module_0.map_index_queries(str_0, str_0)

Coverage: 36.17300131061599
Mutation Score: 5.3700000000000045

Baseline 2 (CodaMosa):
Predicted Test Suite: 
Coverage: -1
Mutation Score: -1

Baseline 3 (GPT-4o):
Predicted Test Suite: 
import pytest
import numpy as np
import pandas as pd
from xarray.core.indexing import (
    IndexSelResult,
    merge_sel_results,
    group_indexers_by_index,
    map_index_queries,
    expanded_indexer,
    slice_slice,
    BasicIndexer,
    OuterIndexer,
    VectorizedIndexer,
    LazilyIndexedArray,
    CopyOnWriteArray,
    MemoryCachedArray,
    NumpyIndexingAdapter,
    PandasIndexingAdapter,
    PandasMultiIndexingAdapter,
    explicit_indexing_adapter,
    IndexingSupport,
    decompose_indexer,
    create_mask,
    posify_mask_indexer,
    is_fancy_indexer,
)

def test_IndexSelResult_as_tuple():
    result = IndexSelResult(
        dim_indexers={'x': 0},
        indexes={'x': 'index'},
        variables={'x': 'variable'},
        drop_coords=['coord'],
        drop_indexes=['index'],
        rename_dims={'old_dim': 'new_dim'}
    )
    assert result.as_tuple() == (
        {'x': 0},
        {'x': 'index'},
        {'x': 'variable'},
        ['coord'],
        ['index'],
        {'old_dim': 'new_dim'}
    )

def test_merge_sel_results():
    result1 = IndexSelResult(dim_indexers={'x': 0})
    result2 = IndexSelResult(dim_indexers={'y': 1})
    merged_result = merge_sel_results([result1, result2])
    assert merged_result.dim_indexers == {'x': 0, 'y': 1}

    with pytest.raises(ValueError):
        result3 = IndexSelResult(dim_indexers={'x': 2})
        merge_sel_results([result1, result3])

def test_group_indexers_by_index():
    class MockXarray:
        xindexes = {'x': 'index_x'}
        coords = {'y': 'coord_y'}
        dims = {'z': 'dim_z'}

    obj = MockXarray()
    indexers = {'x': 0, 'y': 1, 'z': 2}
    options = {}
    grouped = group_indexers_by_index(obj, indexers, options)
    assert len(grouped) == 2
    assert grouped[0] == ('index_x', {'x': 0})

    with pytest.raises(KeyError):
        group_indexers_by_index(obj, {'a': 0}, options)

def test_expanded_indexer():
    key = (Ellipsis, 1)
    ndim = 3
    expanded = expanded_indexer(key, ndim)
    assert expanded == (slice(None), slice(None), 1)

def test_slice_slice():
    old_slice = slice(1, 10, 2)
    applied_slice = slice(1, 3)
    size = 10
    new_slice = slice_slice(old_slice, applied_slice, size)
    assert new_slice == slice(3, 7, 2)

def test_BasicIndexer():
    indexer = BasicIndexer((slice(1, 5), 2))
    assert indexer.tuple == (slice(1, 5), 2)

    with pytest.raises(TypeError):
        BasicIndexer((slice(1, 5), 'a'))

def test_OuterIndexer():
    indexer = OuterIndexer((np.array([0, 1]), slice(2, 5)))
    assert indexer.tuple == (np.array([0, 1]), slice(2, 5))

    with pytest.raises(TypeError):
        OuterIndexer((np.array([0.1, 1.2]), slice(2, 5)))

def test_VectorizedIndexer():
    indexer = VectorizedIndexer((np.array([0, 1]), slice(2, 5)))
    assert indexer.tuple == (np.array([0, 1]), slice(2, 5))

    with pytest.raises(ValueError):
        VectorizedIndexer((np.array([0, 1]), np.array([[2, 3], [4, 5]])))

def test_LazilyIndexedArray():
    array = np.arange(10)
    lazy_array = LazilyIndexedArray(array)
    assert lazy_array[BasicIndexer((slice(1, 5),))].shape == (4,)

def test_CopyOnWriteArray():
    array = np.arange(10)
    cow_array = CopyOnWriteArray(array)
    cow_array[BasicIndexer((slice(1, 5),))] = 100
    assert cow_array.array[1] == 100

def test_MemoryCachedArray():
    array = np.arange(10)
    cached_array = MemoryCachedArray(array)
    assert cached_array[BasicIndexer((slice(1, 5),))].shape == (4,)

def test_NumpyIndexingAdapter():
    array = np.arange(10)
    adapter = NumpyIndexingAdapter(array)
    assert adapter[BasicIndexer((slice(1, 5),))].shape == (4,)

def test_PandasIndexingAdapter():
    index = pd.Index([1, 2, 3, 4, 5])
    adapter = PandasIndexingAdapter(index)
    assert adapter[BasicIndexer((slice(1, 3),))].shape == (2,)

def test_PandasMultiIndexingAdapter():
    index = pd.MultiIndex.from_tuples([(1, 'a'), (2, 'b'), (3, 'c')])
    adapter = PandasMultiIndexingAdapter(index, level=0)
    assert adapter[BasicIndexer((slice(1, 3),))].shape == (2,)

def test_explicit_indexing_adapter():
    array = np.arange(10)
    key = BasicIndexer((slice(1, 5),))
    result = explicit_indexing_adapter(key, array.shape, IndexingSupport.BASIC, lambda k: array[k])
    assert result.shape == (4,)

def test_decompose_indexer():
    indexer = BasicIndexer((slice(1, 5),))
    shape = (10,)
    backend_indexer, np_indexer = decompose_indexer(indexer, shape, IndexingSupport.BASIC)
    assert backend_indexer.tuple == (slice(1, 5),)

def test_create_mask():
    indexer = OuterIndexer((np.array([0, -1, 2]),))
    shape = (5,)
    mask = create_mask(indexer, shape)
    assert mask.shape == (3,)

def test_posify_mask_indexer():
    indexer = OuterIndexer((np.array([0, -1, 2]),))
    posified = posify_mask_indexer(indexer)
    assert np.array_equal(posified.tuple[0], np.array([0, 0, 2]))

def test_is_fancy_indexer():
    assert not is_fancy_indexer(1)
    assert not is_fancy_indexer(slice(1, 5))
    assert is_fancy_indexer(np.array([[1, 2], [3, 4]]))

Coverage: 52.293577981651374
Mutation Score: 30.069999999999993

Approach:
Predicted Test Suite: import pytest
import numpy as np
import pandas as pd
from xarray.core.indexing import (
    IndexSelResult,
    merge_sel_results,
    group_indexers_by_index,
    map_index_queries,
    expanded_indexer,
    slice_slice,
    BasicIndexer,
    OuterIndexer,
    VectorizedIndexer,
    LazilyIndexedArray,
    CopyOnWriteArray,
    MemoryCachedArray,
    NumpyIndexingAdapter,
    PandasIndexingAdapter,
    PandasMultiIndexingAdapter,
    explicit_indexing_adapter,
    IndexingSupport,
    decompose_indexer,
    create_mask,
    posify_mask_indexer,
    is_fancy_indexer,
)

def test_IndexSelResult_as_tuple():
    result = IndexSelResult(
        dim_indexers={'x': 0},
        indexes={'x': 'index'},
        variables={'x': 'variable'},
        drop_coords=['coord'],
        drop_indexes=['index'],
        rename_dims={'old_dim': 'new_dim'}
    )
    assert result.as_tuple() == (
        {'x': 0},
        {'x': 'index'},
        {'x': 'variable'},
        ['coord'],
        ['index'],
        {'old_dim': 'new_dim'}
    )

def test_merge_sel_results():
    result1 = IndexSelResult(dim_indexers={'x': 0})
    result2 = IndexSelResult(dim_indexers={'y': 1})
    merged_result = merge_sel_results([result1, result2])
    assert merged_result.dim_indexers == {'x': 0, 'y': 1}

    with pytest.raises(ValueError):
        result3 = IndexSelResult(dim_indexers={'x': 2})
        merge_sel_results([result1, result3])

def test_group_indexers_by_index():
    class MockXarray:
        xindexes = {'x': 'index_x'}
        coords = {'y': 'coord_y'}
        dims = {'z': 'dim_z'}

    obj = MockXarray()
    indexers = {'x': 0, 'y': 1, 'z': 2}
    options = {}
    grouped = group_indexers_by_index(obj, indexers, options)
    assert len(grouped) == 2
    assert grouped[0] == ('index_x', {'x': 0})

    with pytest.raises(KeyError):
        group_indexers_by_index(obj, {'a': 0}, options)

def test_expanded_indexer():
    key = (Ellipsis, 1)
    ndim = 3
    expanded = expanded_indexer(key, ndim)
    assert expanded == (slice(None), slice(None), 1)

def test_slice_slice():
    old_slice = slice(1, 10, 2)
    applied_slice = slice(1, 3)
    size = 10
    new_slice = slice_slice(old_slice, applied_slice, size)
    assert new_slice == slice(3, 7, 2)

def test_BasicIndexer():
    indexer = BasicIndexer((slice(1, 5), 2))
    assert indexer.tuple == (slice(1, 5), 2)

    with pytest.raises(TypeError):
        BasicIndexer((slice(1, 5), 'a'))

def test_OuterIndexer():
    indexer = OuterIndexer((np.array([0, 1]), slice(2, 5)))
    assert indexer.tuple == (np.array([0, 1]), slice(2, 5))

    with pytest.raises(TypeError):
        OuterIndexer((np.array([0.1, 1.2]), slice(2, 5)))

def test_VectorizedIndexer():
    indexer = VectorizedIndexer((np.array([0, 1]), slice(2, 5)))
    assert indexer.tuple == (np.array([0, 1]), slice(2, 5))

    with pytest.raises(ValueError):
        VectorizedIndexer((np.array([0, 1]), np.array([[2, 3], [4, 5]])))

def test_LazilyIndexedArray():
    array = np.arange(10)
    lazy_array = LazilyIndexedArray(array)
    assert lazy_array[BasicIndexer((slice(1, 5),))].shape == (4,)

def test_CopyOnWriteArray():
    array = np.arange(10)
    cow_array = CopyOnWriteArray(array)
    cow_array[BasicIndexer((slice(1, 5),))] = 100
    assert cow_array.array[1] == 100

def test_MemoryCachedArray():
    array = np.arange(10)
    cached_array = MemoryCachedArray(array)
    assert cached_array[BasicIndexer((slice(1, 5),))].shape == (4,)

def test_NumpyIndexingAdapter():
    array = np.arange(10)
    adapter = NumpyIndexingAdapter(array)
    assert adapter[BasicIndexer((slice(1, 5),))].shape == (4,)

def test_PandasIndexingAdapter():
    index = pd.Index([1, 2, 3, 4, 5])
    adapter = PandasIndexingAdapter(index)
    assert adapter[BasicIndexer((slice(1, 3),))].shape == (2,)

def test_PandasMultiIndexingAdapter():
    index = pd.MultiIndex.from_tuples([(1, 'a'), (2, 'b'), (3, 'c')])
    adapter = PandasMultiIndexingAdapter(index, level=0)
    assert adapter[BasicIndexer((slice(1, 3),))].shape == (2,)

def test_explicit_indexing_adapter():
    array = np.arange(10)
    key = BasicIndexer((slice(1, 5),))
    result = explicit_indexing_adapter(key, array.shape, IndexingSupport.BASIC, lambda k: array[k])
    assert result.shape == (4,)

def test_decompose_indexer():
    indexer = BasicIndexer((slice(1, 5),))
    shape = (10,)
    backend_indexer, np_indexer = decompose_indexer(indexer, shape, IndexingSupport.BASIC)
    assert backend_indexer.tuple == (slice(1, 5),)

def test_create_mask():
    indexer = OuterIndexer((np.array([0, -1, 2]),))
    shape = (5,)
    mask = create_mask(indexer, shape)
    assert mask.shape == (3,)

def test_posify_mask_indexer():
    indexer = OuterIndexer((np.array([0, -1, 2]),))
    posified = posify_mask_indexer(indexer)
    assert np.array_equal(posified.tuple[0], np.array([0, 0, 2]))

def test_is_fancy_indexer():
    assert not is_fancy_indexer(1)
    assert not is_fancy_indexer(slice(1, 5))
    assert is_fancy_indexer(np.array([[1, 2], [3, 4]]))
Coverage: 52.293577981651374
Mutation Score: 29.959999999999994
Output: On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
        xarray/tests/test_indexes.py

nothing added to commit but untracked files present (use "git add" to track)
commit d3f0fe99b3bf6594cceb483a69ef28c1d636afec
Author: TestGenEval <>
Date:   Wed Dec 11 13:21:35 2024 +0000

    Testing fixes

diff --git a/xarray/core/indexing.py b/xarray/core/indexing.py
index ba937183..e49a072d 100644
--- a/xarray/core/indexing.py
+++ b/xarray/core/indexing.py
@@ -1531,8 +1531,12 @@ class PandasMultiIndexingAdapter(PandasIndexingAdapter):
         self.level = level

     def __array__(self, dtype: DTypeLike = None) -> np.ndarray:
+        if dtype is None:
+            dtype = self.dtype
         if self.level is not None:
-            return self.array.get_level_values(self.level).values
+            return np.asarray(
+                self.array.get_level_values(self.level).values, dtype=dtype
+            )
         else:
             return super().__array__(dtype)

diff --git a/xarray/tests/test_indexes.py b/xarray/tests/test_indexes.py
deleted file mode 100644
index 3ecfa73c..00000000
--- a/xarray/tests/test_indexes.py
+++ /dev/null
@@ -1,699 +0,0 @@
-from __future__ import annotations
-
-import copy
-from datetime import datetime
-from typing import Any
-
-import numpy as np
-import pandas as pd
-import pytest
-
-import xarray as xr
-from xarray.coding.cftimeindex import CFTimeIndex
-from xarray.core.indexes import (
-    Hashable,
-    Index,
-    Indexes,
-    PandasIndex,
-    PandasMultiIndex,
-    _asarray_tuplesafe,
-    safe_cast_to_index,
-)
-from xarray.core.variable import IndexVariable, Variable
-from xarray.tests import assert_array_equal, assert_identical, requires_cftime
-from xarray.tests.test_coding_times import _all_cftime_date_types
-
-
-def test_asarray_tuplesafe() -> None:
-    res = _asarray_tuplesafe(("a", 1))
-    assert isinstance(res, np.ndarray)
-    assert res.ndim == 0
-    assert res.item() == ("a", 1)
-
-    res = _asarray_tuplesafe([(0,), (1,)])
-    assert res.shape == (2,)
-    assert res[0] == (0,)
-    assert res[1] == (1,)
-
-
-class CustomIndex(Index):
-    def __init__(self, dims) -> None:
-        self.dims = dims
-
-
-class TestIndex:
-    @pytest.fixture
-    def index(self) -> CustomIndex:
-        return CustomIndex({"x": 2})
-
-    def test_from_variables(self) -> None:
-        with pytest.raises(NotImplementedError):
-            Index.from_variables({}, options={})
-
-    def test_concat(self) -> None:
-        with pytest.raises(NotImplementedError):
-            Index.concat([], "x")
-
-    def test_stack(self) -> None:
-        with pytest.raises(NotImplementedError):
-            Index.stack({}, "x")
-
-    def test_unstack(self, index) -> None:
-        with pytest.raises(NotImplementedError):
-            index.unstack()
-
-    def test_create_variables(self, index) -> None:
-        assert index.create_variables() == {}
-        assert index.create_variables({"x": "var"}) == {"x": "var"}
-
-    def test_to_pandas_index(self, index) -> None:
-        with pytest.raises(TypeError):
-            index.to_pandas_index()
-
-    def test_isel(self, index) -> None:
-        assert index.isel({}) is None
-
-    def test_sel(self, index) -> None:
-        with pytest.raises(NotImplementedError):
-            index.sel({})
-
-    def test_join(self, index) -> None:
-        with pytest.raises(NotImplementedError):
-            index.join(CustomIndex({"y": 2}))
-
-    def test_reindex_like(self, index) -> None:
-        with pytest.raises(NotImplementedError):
-            index.reindex_like(CustomIndex({"y": 2}))
-
-    def test_equals(self, index) -> None:
-        with pytest.raises(NotImplementedError):
-            index.equals(CustomIndex({"y": 2}))
-
-    def test_roll(self, index) -> None:
-        assert index.roll({}) is None
-
-    def test_rename(self, index) -> None:
-        assert index.rename({}, {}) is index
-
-    @pytest.mark.parametrize("deep", [True, False])
-    def test_copy(self, index, deep) -> None:
-        copied = index.copy(deep=deep)
-        assert isinstance(copied, CustomIndex)
-        assert copied is not index
-
-        copied.dims["x"] = 3
-        if deep:
-            assert copied.dims != index.dims
-            assert copied.dims != copy.deepcopy(index).dims
-        else:
-            assert copied.dims is index.dims
-            assert copied.dims is copy.copy(index).dims
-
-    def test_getitem(self, index) -> None:
-        with pytest.raises(NotImplementedError):
-            index[:]
-
-
-class TestPandasIndex:
-    def test_constructor(self) -> None:
-        pd_idx = pd.Index([1, 2, 3])
-        index = PandasIndex(pd_idx, "x")
-
-        assert index.index.equals(pd_idx)
-        # makes a shallow copy
-        assert index.index is not pd_idx
-        assert index.dim == "x"
-
-        # test no name set for pd.Index
-        pd_idx.name = None
-        index = PandasIndex(pd_idx, "x")
-        assert index.index.name == "x"
-
-    def test_from_variables(self) -> None:
-        # pandas has only Float64Index but variable dtype should be preserved
-        data = np.array([1.1, 2.2, 3.3], dtype=np.float32)
-        var = xr.Variable(
-            "x", data, attrs={"unit": "m"}, encoding={"dtype": np.float64}
-        )
-
-        index = PandasIndex.from_variables({"x": var}, options={})
-        assert index.dim == "x"
-        assert index.index.equals(pd.Index(data))
-        assert index.coord_dtype == data.dtype
-
-        var2 = xr.Variable(("x", "y"), [[1, 2, 3], [4, 5, 6]])
-        with pytest.raises(ValueError, match=r".*only accepts one variable.*"):
-            PandasIndex.from_variables({"x": var, "foo": var2}, options={})
-
-        with pytest.raises(
-            ValueError, match=r".*only accepts a 1-dimensional variable.*"
-        ):
-            PandasIndex.from_variables({"foo": var2}, options={})
-
-    def test_from_variables_index_adapter(self) -> None:
-        # test index type is preserved when variable wraps a pd.Index
-        data = pd.Series(["foo", "bar"], dtype="category")
-        pd_idx = pd.Index(data)
-        var = xr.Variable("x", pd_idx)
-
-        index = PandasIndex.from_variables({"x": var}, options={})
-        assert isinstance(index.index, pd.CategoricalIndex)
-
-    def test_concat_periods(self):
-        periods = pd.period_range("2000-01-01", periods=10)
-        indexes = [PandasIndex(periods[:5], "t"), PandasIndex(periods[5:], "t")]
-        expected = PandasIndex(periods, "t")
-        actual = PandasIndex.concat(indexes, dim="t")
-        assert actual.equals(expected)
-        assert isinstance(actual.index, pd.PeriodIndex)
-
-        positions = [list(range(5)), list(range(5, 10))]
-        actual = PandasIndex.concat(indexes, dim="t", positions=positions)
-        assert actual.equals(expected)
-        assert isinstance(actual.index, pd.PeriodIndex)
-
-    @pytest.mark.parametrize("dtype", [str, bytes])
-    def test_concat_str_dtype(self, dtype) -> None:
-
-        a = PandasIndex(np.array(["a"], dtype=dtype), "x", coord_dtype=dtype)
-        b = PandasIndex(np.array(["b"], dtype=dtype), "x", coord_dtype=dtype)
-        expected = PandasIndex(
-            np.array(["a", "b"], dtype=dtype), "x", coord_dtype=dtype
-        )
-
-        actual = PandasIndex.concat([a, b], "x")
-        assert actual.equals(expected)
-        assert np.issubdtype(actual.coord_dtype, dtype)
-
-    def test_concat_empty(self) -> None:
-        idx = PandasIndex.concat([], "x")
-        assert idx.coord_dtype is np.dtype("O")
-
-    def test_concat_dim_error(self) -> None:
-        indexes = [PandasIndex([0, 1], "x"), PandasIndex([2, 3], "y")]
-
-        with pytest.raises(ValueError, match=r"Cannot concatenate.*dimensions.*"):
-            PandasIndex.concat(indexes, "x")
-
-    def test_create_variables(self) -> None:
-        # pandas has only Float64Index but variable dtype should be preserved
-        data = np.array([1.1, 2.2, 3.3], dtype=np.float32)
-        pd_idx = pd.Index(data, name="foo")
-        index = PandasIndex(pd_idx, "x", coord_dtype=data.dtype)
-        index_vars = {
-            "foo": IndexVariable(
-                "x", data, attrs={"unit": "m"}, encoding={"fill_value": 0.0}
-            )
-        }
-
-        actual = index.create_variables(index_vars)
-        assert_identical(actual["foo"], index_vars["foo"])
-        assert actual["foo"].dtype == index_vars["foo"].dtype
-        assert actual["foo"].dtype == index.coord_dtype
-
-    def test_to_pandas_index(self) -> None:
-        pd_idx = pd.Index([1, 2, 3], name="foo")
-        index = PandasIndex(pd_idx, "x")
-        assert index.to_pandas_index() is index.index
-
-    def test_sel(self) -> None:
-        # TODO: add tests that aren't just for edge cases
-        index = PandasIndex(pd.Index([1, 2, 3]), "x")
-        with pytest.raises(KeyError, match=r"not all values found"):
-            index.sel({"x": [0]})
-        with pytest.raises(KeyError):
-            index.sel({"x": 0})
-        with pytest.raises(ValueError, match=r"does not have a MultiIndex"):
-            index.sel({"x": {"one": 0}})
-
-    def test_sel_boolean(self) -> None:
-        # index should be ignored and indexer dtype should not be coerced
-        # see https://github.com/pydata/xarray/issues/5727
-        index = PandasIndex(pd.Index([0.0, 2.0, 1.0, 3.0]), "x")
-        actual = index.sel({"x": [False, True, False, True]})
-        expected_dim_indexers = {"x": [False, True, False, True]}
-        np.testing.assert_array_equal(
-            actual.dim_indexers["x"], expected_dim_indexers["x"]
-        )
-
-    def test_sel_datetime(self) -> None:
-        index = PandasIndex(
-            pd.to_datetime(["2000-01-01", "2001-01-01", "2002-01-01"]), "x"
-        )
-        actual = index.sel({"x": "2001-01-01"})
-        expected_dim_indexers = {"x": 1}
-        assert actual.dim_indexers == expected_dim_indexers
-
-        actual = index.sel({"x": index.to_pandas_index().to_numpy()[1]})
-        assert actual.dim_indexers == expected_dim_indexers
-
-    def test_sel_unsorted_datetime_index_raises(self) -> None:
-        index = PandasIndex(pd.to_datetime(["2001", "2000", "2002"]), "x")
-        with pytest.raises(KeyError):
-            # pandas will try to convert this into an array indexer. We should
-            # raise instead, so we can be sure the result of indexing with a
-            # slice is always a view.
-            index.sel({"x": slice("2001", "2002")})
-
-    def test_equals(self) -> None:
-        index1 = PandasIndex([1, 2, 3], "x")
-        index2 = PandasIndex([1, 2, 3], "x")
-        assert index1.equals(index2) is True
-
-    def test_join(self) -> None:
-        index1 = PandasIndex(["a", "aa", "aaa"], "x", coord_dtype="<U3")
-        index2 = PandasIndex(["aa", "aaa", "aaaa"], "x", coord_dtype="<U4")
-
-        expected = PandasIndex(["aa", "aaa"], "x")
-        actual = index1.join(index2)
-        print(actual.index)
-        assert actual.equals(expected)
-        assert actual.coord_dtype == "=U4"
-
-        expected = PandasIndex(["a", "aa", "aaa", "aaaa"], "x")
-        actual = index1.join(index2, how="outer")
-        print(actual.index)
-        assert actual.equals(expected)
-        assert actual.coord_dtype == "=U4"
-
-    def test_reindex_like(self) -> None:
-        index1 = PandasIndex([0, 1, 2], "x")
-        index2 = PandasIndex([1, 2, 3, 4], "x")
-
-        expected = {"x": [1, 2, -1, -1]}
-        actual = index1.reindex_like(index2)
-        assert actual.keys() == expected.keys()
-        np.testing.assert_array_equal(actual["x"], expected["x"])
-
-        index3 = PandasIndex([1, 1, 2], "x")
-        with pytest.raises(ValueError, match=r".*index has duplicate values"):
-            index3.reindex_like(index2)
-
-    def test_rename(self) -> None:
-        index = PandasIndex(pd.Index([1, 2, 3], name="a"), "x", coord_dtype=np.int32)
-
-        # shortcut
-        new_index = index.rename({}, {})
-        assert new_index is index
-
-        new_index = index.rename({"a": "b"}, {})
-        assert new_index.index.name == "b"
-        assert new_index.dim == "x"
-        assert new_index.coord_dtype == np.int32
-
-        new_index = index.rename({}, {"x": "y"})
-        assert new_index.index.name == "a"
-        assert new_index.dim == "y"
-        assert new_index.coord_dtype == np.int32
-
-    def test_copy(self) -> None:
-        expected = PandasIndex([1, 2, 3], "x", coord_dtype=np.int32)
-        actual = expected.copy()
-
-        assert actual.index.equals(expected.index)
-        assert actual.index is not expected.index
-        assert actual.dim == expected.dim
-        assert actual.coord_dtype == expected.coord_dtype
-
-    def test_getitem(self) -> None:
-        pd_idx = pd.Index([1, 2, 3])
-        expected = PandasIndex(pd_idx, "x", coord_dtype=np.int32)
-        actual = expected[1:]
-
-        assert actual.index.equals(pd_idx[1:])
-        assert actual.dim == expected.dim
-        assert actual.coord_dtype == expected.coord_dtype
-
-
-class TestPandasMultiIndex:
-    def test_constructor(self) -> None:
-        foo_data = np.array([0, 0, 1], dtype="int64")
-        bar_data = np.array([1.1, 1.2, 1.3], dtype="float64")
-        pd_idx = pd.MultiIndex.from_arrays([foo_data, bar_data], names=("foo", "bar"))
-
-        index = PandasMultiIndex(pd_idx, "x")
-
-        assert index.dim == "x"
-        assert index.index.equals(pd_idx)
-        assert index.index.names == ("foo", "bar")
-        assert index.index.name == "x"
-        assert index.level_coords_dtype == {
-            "foo": foo_data.dtype,
-            "bar": bar_data.dtype,
-        }
-
-        with pytest.raises(ValueError, match=".*conflicting multi-index level name.*"):
-            PandasMultiIndex(pd_idx, "foo")
-
-        # default level names
-        pd_idx = pd.MultiIndex.from_arrays([foo_data, bar_data])
-        index = PandasMultiIndex(pd_idx, "x")
-        assert index.index.names == ("x_level_0", "x_level_1")
-
-    def test_from_variables(self) -> None:
-        v_level1 = xr.Variable(
-            "x", [1, 2, 3], attrs={"unit": "m"}, encoding={"dtype": np.int32}
-        )
-        v_level2 = xr.Variable(
-            "x", ["a", "b", "c"], attrs={"unit": "m"}, encoding={"dtype": "U"}
-        )
-
-        index = PandasMultiIndex.from_variables(
-            {"level1": v_level1, "level2": v_level2}, options={}
-        )
-
-        expected_idx = pd.MultiIndex.from_arrays([v_level1.data, v_level2.data])
-        assert index.dim == "x"
-        assert index.index.equals(expected_idx)
-        assert index.index.name == "x"
-        assert index.index.names == ["level1", "level2"]
-
-        var = xr.Variable(("x", "y"), [[1, 2, 3], [4, 5, 6]])
-        with pytest.raises(
-            ValueError, match=r".*only accepts 1-dimensional variables.*"
-        ):
-            PandasMultiIndex.from_variables({"var": var}, options={})
-
-        v_level3 = xr.Variable("y", [4, 5, 6])
-        with pytest.raises(
-            ValueError, match=r"unmatched dimensions for multi-index variables.*"
-        ):
-            PandasMultiIndex.from_variables(
-                {"level1": v_level1, "level3": v_level3}, options={}
-            )
-
-    def test_concat(self) -> None:
-        pd_midx = pd.MultiIndex.from_product(
-            [[0, 1, 2], ["a", "b"]], names=("foo", "bar")
-        )
-        level_coords_dtype = {"foo": np.int32, "bar": "=U1"}
-
-        midx1 = PandasMultiIndex(
-            pd_midx[:2], "x", level_coords_dtype=level_coords_dtype
-        )
-        midx2 = PandasMultiIndex(
-            pd_midx[2:], "x", level_coords_dtype=level_coords_dtype
-        )
-        expected = PandasMultiIndex(pd_midx, "x", level_coords_dtype=level_coords_dtype)
-
-        actual = PandasMultiIndex.concat([midx1, midx2], "x")
-        assert actual.equals(expected)
-        assert actual.level_coords_dtype == expected.level_coords_dtype
-
-    def test_stack(self) -> None:
-        prod_vars = {
-            "x": xr.Variable("x", pd.Index(["b", "a"]), attrs={"foo": "bar"}),
-            "y": xr.Variable("y", pd.Index([1, 3, 2])),
-        }
-
-        index = PandasMultiIndex.stack(prod_vars, "z")
-
-        assert index.dim == "z"
-        assert index.index.names == ["x", "y"]
-        np.testing.assert_array_equal(
-            index.index.codes, [[0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]]
-        )
-
-        with pytest.raises(
-            ValueError, match=r"conflicting dimensions for multi-index product.*"
-        ):
-            PandasMultiIndex.stack(
-                {"x": xr.Variable("x", ["a", "b"]), "x2": xr.Variable("x", [1, 2])},
-                "z",
-            )
-
-    def test_stack_non_unique(self) -> None:
-        prod_vars = {
-            "x": xr.Variable("x", pd.Index(["b", "a"]), attrs={"foo": "bar"}),
-            "y": xr.Variable("y", pd.Index([1, 1, 2])),
-        }
-
-        index = PandasMultiIndex.stack(prod_vars, "z")
-
-        np.testing.assert_array_equal(
-            index.index.codes, [[0, 0, 0, 1, 1, 1], [0, 0, 1, 0, 0, 1]]
-        )
-        np.testing.assert_array_equal(index.index.levels[0], ["b", "a"])
-        np.testing.assert_array_equal(index.index.levels[1], [1, 2])
-
-    def test_unstack(self) -> None:
-        pd_midx = pd.MultiIndex.from_product(
-            [["a", "b"], [1, 2, 3]], names=["one", "two"]
-        )
-        index = PandasMultiIndex(pd_midx, "x")
-
-        new_indexes, new_pd_idx = index.unstack()
-        assert list(new_indexes) == ["one", "two"]
-        assert new_indexes["one"].equals(PandasIndex(["a", "b"], "one"))
-        assert new_indexes["two"].equals(PandasIndex([1, 2, 3], "two"))
-        assert new_pd_idx.equals(pd_midx)
-
-    def test_create_variables(self) -> None:
-        foo_data = np.array([0, 0, 1], dtype="int64")
-        bar_data = np.array([1.1, 1.2, 1.3], dtype="float64")
-        pd_idx = pd.MultiIndex.from_arrays([foo_data, bar_data], names=("foo", "bar"))
-        index_vars = {
-            "x": IndexVariable("x", pd_idx),
-            "foo": IndexVariable("x", foo_data, attrs={"unit": "m"}),
-            "bar": IndexVariable("x", bar_data, encoding={"fill_value": 0}),
-        }
-
-        index = PandasMultiIndex(pd_idx, "x")
-        actual = index.create_variables(index_vars)
-
-        for k, expected in index_vars.items():
-            assert_identical(actual[k], expected)
-            assert actual[k].dtype == expected.dtype
-            if k != "x":
-                assert actual[k].dtype == index.level_coords_dtype[k]
-
-    def test_sel(self) -> None:
-        index = PandasMultiIndex(
-            pd.MultiIndex.from_product([["a", "b"], [1, 2]], names=("one", "two")), "x"
-        )
-
-        # test tuples inside slice are considered as scalar indexer values
-        actual = index.sel({"x": slice(("a", 1), ("b", 2))})
-        expected_dim_indexers = {"x": slice(0, 4)}
-        assert actual.dim_indexers == expected_dim_indexers
-
-        with pytest.raises(KeyError, match=r"not all values found"):
-            index.sel({"x": [0]})
-        with pytest.raises(KeyError):
-            index.sel({"x": 0})
-        with pytest.raises(ValueError, match=r"cannot provide labels for both.*"):
-            index.sel({"one": 0, "x": "a"})
-        with pytest.raises(ValueError, match=r"invalid multi-index level names"):
-            index.sel({"x": {"three": 0}})
-        with pytest.raises(IndexError):
-            index.sel({"x": (slice(None), 1, "no_level")})
-
-    def test_join(self):
-        midx = pd.MultiIndex.from_product([["a", "aa"], [1, 2]], names=("one", "two"))
-        level_coords_dtype = {"one": "=U2", "two": "i"}
-        index1 = PandasMultiIndex(midx, "x", level_coords_dtype=level_coords_dtype)
-        index2 = PandasMultiIndex(midx[0:2], "x", level_coords_dtype=level_coords_dtype)
-
-        actual = index1.join(index2)
-        assert actual.equals(index2)
-        assert actual.level_coords_dtype == level_coords_dtype
-
-        actual = index1.join(index2, how="outer")
-        assert actual.equals(index1)
-        assert actual.level_coords_dtype == level_coords_dtype
-
-    def test_rename(self) -> None:
-        level_coords_dtype = {"one": "<U1", "two": np.int32}
-        index = PandasMultiIndex(
-            pd.MultiIndex.from_product([["a", "b"], [1, 2]], names=("one", "two")),
-            "x",
-            level_coords_dtype=level_coords_dtype,
-        )
-
-        # shortcut
-        new_index = index.rename({}, {})
-        assert new_index is index
-
-        new_index = index.rename({"two": "three"}, {})
-        assert new_index.index.names == ["one", "three"]
-        assert new_index.dim == "x"
-        assert new_index.level_coords_dtype == {"one": "<U1", "three": np.int32}
-
-        new_index = index.rename({}, {"x": "y"})
-        assert new_index.index.names == ["one", "two"]
-        assert new_index.dim == "y"
-        assert new_index.level_coords_dtype == level_coords_dtype
-
-    def test_copy(self) -> None:
-        level_coords_dtype = {"one": "U<1", "two": np.int32}
-        expected = PandasMultiIndex(
-            pd.MultiIndex.from_product([["a", "b"], [1, 2]], names=("one", "two")),
-            "x",
-            level_coords_dtype=level_coords_dtype,
-        )
-        actual = expected.copy()
-
-        assert actual.index.equals(expected.index)
-        assert actual.index is not expected.index
-        assert actual.dim == expected.dim
-        assert actual.level_coords_dtype == expected.level_coords_dtype
-
-
-class TestIndexes:
-    @pytest.fixture
-    def indexes_and_vars(self) -> tuple[list[PandasIndex], dict[Hashable, Variable]]:
-        x_idx = PandasIndex(pd.Index([1, 2, 3], name="x"), "x")
-        y_idx = PandasIndex(pd.Index([4, 5, 6], name="y"), "y")
-        z_pd_midx = pd.MultiIndex.from_product(
-            [["a", "b"], [1, 2]], names=["one", "two"]
-        )
-        z_midx = PandasMultiIndex(z_pd_midx, "z")
-
-        indexes = [x_idx, y_idx, z_midx]
-
-        variables = {}
-        for idx in indexes:
-            variables.update(idx.create_variables())
-
-        return indexes, variables
-
-    @pytest.fixture(params=["pd_index", "xr_index"])
-    def unique_indexes(
-        self, request, indexes_and_vars
-    ) -> list[PandasIndex] | list[pd.Index]:
-        xr_indexes, _ = indexes_and_vars
-
-        if request.param == "pd_index":
-            return [idx.index for idx in xr_indexes]
-        else:
-            return xr_indexes
-
-    @pytest.fixture
-    def indexes(
-        self, unique_indexes, indexes_and_vars
-    ) -> Indexes[Index] | Indexes[pd.Index]:
-        x_idx, y_idx, z_midx = unique_indexes
-        indexes: dict[Any, Index] = {
-            "x": x_idx,
-            "y": y_idx,
-            "z": z_midx,
-            "one": z_midx,
-            "two": z_midx,
-        }
-
-        _, variables = indexes_and_vars
-
-        return Indexes(indexes, variables)
-
-    def test_interface(self, unique_indexes, indexes) -> None:
-        x_idx = unique_indexes[0]
-        assert list(indexes) == ["x", "y", "z", "one", "two"]
-        assert len(indexes) == 5
-        assert "x" in indexes
-        assert indexes["x"] is x_idx
-
-    def test_variables(self, indexes) -> None:
-        assert tuple(indexes.variables) == ("x", "y", "z", "one", "two")
-
-    def test_dims(self, indexes) -> None:
-        assert indexes.dims == {"x": 3, "y": 3, "z": 4}
-
-    def test_get_unique(self, unique_indexes, indexes) -> None:
-        assert indexes.get_unique() == unique_indexes
-
-    def test_is_multi(self, indexes) -> None:
-        assert indexes.is_multi("one") is True
-        assert indexes.is_multi("x") is False
-
-    def test_get_all_coords(self, indexes) -> None:
-        expected = {
-            "z": indexes.variables["z"],
-            "one": indexes.variables["one"],
-            "two": indexes.variables["two"],
-        }
-        assert indexes.get_all_coords("one") == expected
-
-        with pytest.raises(ValueError, match="errors must be.*"):
-            indexes.get_all_coords("x", errors="invalid")
-
-        with pytest.raises(ValueError, match="no index found.*"):
-            indexes.get_all_coords("no_coord")
-
-        assert indexes.get_all_coords("no_coord", errors="ignore") == {}
-
-    def test_get_all_dims(self, indexes) -> None:
-        expected = {"z": 4}
-        assert indexes.get_all_dims("one") == expected
-
-    def test_group_by_index(self, unique_indexes, indexes):
-        expected = [
-            (unique_indexes[0], {"x": indexes.variables["x"]}),
-            (unique_indexes[1], {"y": indexes.variables["y"]}),
-            (
-                unique_indexes[2],
-                {
-                    "z": indexes.variables["z"],
-                    "one": indexes.variables["one"],
-                    "two": indexes.variables["two"],
-                },
-            ),
-        ]
-
-        assert indexes.group_by_index() == expected
-
-    def test_to_pandas_indexes(self, indexes) -> None:
-        pd_indexes = indexes.to_pandas_indexes()
-        assert isinstance(pd_indexes, Indexes)
-        assert all([isinstance(idx, pd.Index) for idx in pd_indexes.values()])
-        assert indexes.variables == pd_indexes.variables
-
-    def test_copy_indexes(self, indexes) -> None:
-        copied, index_vars = indexes.copy_indexes()
-
-        assert copied.keys() == indexes.keys()
-        for new, original in zip(copied.values(), indexes.values()):
-            assert new.equals(original)
-        # check unique index objects preserved
-        assert copied["z"] is copied["one"] is copied["two"]
-
-        assert index_vars.keys() == indexes.variables.keys()
-        for new, original in zip(index_vars.values(), indexes.variables.values()):
-            assert_identical(new, original)
-
-
-def test_safe_cast_to_index():
-    dates = pd.date_range("2000-01-01", periods=10)
-    x = np.arange(5)
-    td = x * np.timedelta64(1, "D")
-    for expected, array in [
-        (dates, dates.values),
-        (pd.Index(x, dtype=object), x.astype(object)),
-        (pd.Index(td), td),
-        (pd.Index(td, dtype=object), td.astype(object)),
-    ]:
-        actual = safe_cast_to_index(array)
-        assert_array_equal(expected, actual)
-        assert expected.dtype == actual.dtype
-
-
-@requires_cftime
-def test_safe_cast_to_index_cftimeindex():
-    date_types = _all_cftime_date_types()
-    for date_type in date_types.values():
-        dates = [date_type(1, 1, day) for day in range(1, 20)]
-        expected = CFTimeIndex(dates)
-        actual = safe_cast_to_index(np.array(dates))
-        assert_array_equal(expected, actual)
-        assert expected.dtype == actual.dtype
-        assert isinstance(actual, type(expected))
-
-
-# Test that datetime.datetime objects are never used in a CFTimeIndex
-@requires_cftime
-def test_safe_cast_to_index_datetime_datetime():
-    dates = [datetime(1, 1, day) for day in range(1, 20)]
-
-    expected = pd.Index(dates)
-    actual = safe_cast_to_index(np.array(dates))
-    assert_array_equal(expected, actual)
-    assert isinstance(actual, pd.Index)
Obtaining file:///testbed
  Installing build dependencies: started
  Installing build dependencies: finished with status 'done'
  Checking if build backend supports build_editable: started
  Checking if build backend supports build_editable: finished with status 'done'
  Getting requirements to build editable: started
  Getting requirements to build editable: finished with status 'done'
  Preparing editable metadata (pyproject.toml): started
  Preparing editable metadata (pyproject.toml): finished with status 'done'
Requirement already satisfied: numpy>=1.20 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==2022.12.1.dev11+gd3f0fe99) (1.23.0)
Requirement already satisfied: pandas>=1.3 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==2022.12.1.dev11+gd3f0fe99) (1.5.3)
Requirement already satisfied: packaging>=21.3 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from xarray==2022.12.1.dev11+gd3f0fe99) (23.1)
Requirement already satisfied: python-dateutil>=2.8.1 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from pandas>=1.3->xarray==2022.12.1.dev11+gd3f0fe99) (2.8.2)
Requirement already satisfied: pytz>=2020.1 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from pandas>=1.3->xarray==2022.12.1.dev11+gd3f0fe99) (2023.3)
Requirement already satisfied: six>=1.5 in /opt/miniconda3/envs/testbed/lib/python3.10/site-packages (from python-dateutil>=2.8.1->pandas>=1.3->xarray==2022.12.1.dev11+gd3f0fe99) (1.16.0)
Building wheels for collected packages: xarray
  Building editable for xarray (pyproject.toml): started
  Building editable for xarray (pyproject.toml): finished with status 'done'
  Created wheel for xarray: filename=xarray-2022.12.1.dev11+gd3f0fe99-0.editable-py3-none-any.whl size=8994 sha256=06a965ac9ded99ce3506050a9184ef3963f10471cd7fa08d204797fcb376094d
  Stored in directory: /tmp/pip-ephem-wheel-cache-yjokh7ze/wheels/0d/a6/cb/465a7b303d624cc531250fa27c75d038ddc29430bdb6ba7c9f
Successfully built xarray
Installing collected packages: xarray
  Attempting uninstall: xarray
    Found existing installation: xarray 2022.12.1.dev11+gd3f0fe99
    Uninstalling xarray-2022.12.1.dev11+gd3f0fe99:
      Successfully uninstalled xarray-2022.12.1.dev11+gd3f0fe99
Successfully installed xarray-2022.12.1.dev11+gd3f0fe99
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable.It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
============================= test session starts ==============================
platform linux -- Python 3.10.14, pytest-7.4.0, pluggy-1.5.0
rootdir: /testbed
configfile: setup.cfg
plugins: env-1.1.3, cov-5.0.0, hypothesis-6.108.5, timeout-2.3.1, xdist-3.6.1
collected 15 items

xarray/tests/test_indexes.py ...............                             [100%]

=============================== warnings summary ===============================
../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pydap/lib.py:5
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pydap/lib.py:5: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html
    from pkg_resources import get_distribution

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap.responses')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2350
../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2350
../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2350
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2350: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(parent)

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap.handlers')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

../opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871
  /opt/miniconda3/envs/testbed/lib/python3.10/site-packages/pkg_resources/__init__.py:2871: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('pydap.tests')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
==================================== PASSES ====================================
=========================== short test summary info ============================
PASSED xarray/tests/test_indexes.py::test_IndexSelResult_as_tuple
PASSED xarray/tests/test_indexes.py::test_merge_sel_results
PASSED xarray/tests/test_indexes.py::test_expanded_indexer
PASSED xarray/tests/test_indexes.py::test_slice_slice
PASSED xarray/tests/test_indexes.py::test_BasicIndexer
PASSED xarray/tests/test_indexes.py::test_LazilyIndexedArray
PASSED xarray/tests/test_indexes.py::test_MemoryCachedArray
PASSED xarray/tests/test_indexes.py::test_NumpyIndexingAdapter
PASSED xarray/tests/test_indexes.py::test_PandasIndexingAdapter
PASSED xarray/tests/test_indexes.py::test_PandasMultiIndexingAdapter
PASSED xarray/tests/test_indexes.py::test_explicit_indexing_adapter
PASSED xarray/tests/test_indexes.py::test_decompose_indexer
PASSED xarray/tests/test_indexes.py::test_create_mask
PASSED xarray/tests/test_indexes.py::test_posify_mask_indexer
PASSED xarray/tests/test_indexes.py::test_is_fancy_indexer
======================== 15 passed, 8 warnings in 0.34s ========================

